w1       68000 read (any size)
w2       Address == ($0xxxxx or $8xxxxx) and no CPU interrupt acknowledge (w35)?
w4       Release 68000 bus (used by DMA)
w5       Request 68000 bus (used by DMA)
w6       Clear during the 2nd and 4th cycle of a refresh slot
w7       Set during the 2nd and 4th cycle of a refresh slot if FIFO is not full
w8       Set while in DMA transfer (after it has been going for at least 1 cycle)
w9       Set when any interrupt pending
w11      IRQ number to assert (bit 1)
w12      IRQ number to assert (bit 2)
w35      No CPU interrupt acknowledge?
w37      No CPU address strobe (68000)
w43      Set when counter dff23..29_l2 == 127
w44      (partial result for w43, see above)
w45      CPU interrupt acknowledge (68000)
w46      CPU interrupt acknowledge
w47      CPU interrupt acknowledge (Z80)
w48      CPU interrupt acknowledge in mode 5
w49      Clear pending interrupts (from l9, from w48)
w50      Reset OR read enable CTRL
w54      Clear external interrupt pending
w56      Clear vblank interrupt pending (F flag)
w57      Set to trigger hblank interrupt
w58      Set to trigger external interrupt
w59      Set external interrupt pending
w60      Set to trigger vblank interrupt
w61      Allow DMA flag
w62      Start DMA transfer
w63      Start DMA copy or fill
w64      Assert BGACK (high logic)
w65      Swap status port bits 1:0 with 9:8 (req: SMS mode, mode 5, mirror status port, wtf?)
w66      Set sprite overflow flag
w70      68k within VDP address range (address must be 110xx000 xxxxxxxx 000xxxxx)
w71      Output extra V and H counter bits over CPU data bus (test feature, SMS mode only)
w72      Status port PAL bit (or FIFO full if w65 set)
w73      Status port DMA bit (or FIFO empty if w65 set)
w74      Selected test port $F
w75      Selected test port $8
w76      Selected test port $7
w77      Selected test port $6
w78      Selected test port $5
w79      Selected test port $4
w80      Selected test port $3
w81      Selected test port $2
w82      Selected test port $1
w83      Selected test port $0
w84      Write enable for test port $0
w85      Write enable for test port $1
w86      Write enable for test port $2
w87      Read enable for test port $2
w88      Write enable for test port $3
w89      Read enable for test port $3
w90      Write enable for test port $4
w91      Read enable for test port $4
w92      Write enable for test port $5
w93      Read enable for test port $5
w94      Write enable for test port $6
w95      Read enable for test port $6
w96      Write enable for test port $7
w97      Read enable for test port $7
w98      Write enable for test port $8
w99      Read enable for test port $8
w100     Read enable for test port $F? (works different than usual)
w101     DRAM row and column mux select (passed to w103)
w103     RA output, color bus vs. DRAM address mux (involves reg $0B bit 7 and w101)
w104     DRAM ASEL signal (involves reg $0B bit 7)
w105     ??? (controlled by debug reg $00 bit 0, involves color)
w106     Interlaced mode 2 enable (high resolution)
w107     V28 enable
w108     V30 enable
w109     128KB mode enable
w110     Write enable for PSG (SMS mode)
w111     Write enable for PSG
w112     Read enable for DATA/CTRL (SMS mode)
w113     Read enable for DATA/CTRL
w114     Read enable for CTRL
w117     /DTACK?
w120     Set F flag, also sets whatever is t12 (see w121)
w121     ??? (resets t12)
w122     Fire the interrupt (be more specific? high or low logic?) (68k=t12, Z80=w9)
w123     V counter latch bottom bit
w124     68000 CPU access detected
w128     Write enable for debug address port (MD mode)
w129     Write enable for debug data port (MD mode)
w130     Select between subports (for paired ports)
w131     Write enable for DATA/CTRL (MD mode)
w132     Read enable for DATA/CTRL (MD mode)
w133     Write enable for PSG (MD mode)
w134     Read enable for latched V counter // Read enable for HV counter (MD mode)
w135     Read enable for debug register (MD mode)
w136     End of DMA transfer (or reset)
w137     Assert /DTACK (seems logic for halting on DMA transfers and for halting on reads)
w138     Seems to be set when data is available to read
w139     Write enable for DATA/CTRL
w140     Write enable for DATA/CTRL (SMS mode)
w141     Read enable for HV counter (SMS mode)
w142     Read enable for latched H counter // Read enable for HV counter
w143     Read enable for DATA? (used for t14 and t24)
w144     (clears t18, seems related to CPU writes)
w145     (sets t18, seems related to CPU writes)
w146     Part of /DTACK logic (all this goes to w117)
w147     CPU strobe (either upper or lower)
w151     (low logic) VRAM data output strobe
w153     DATA/CTRL access strobe for w150
w155     Select high word for next command write?
w156     FIFO empty or end of DMA
w159     ??? (something to do with end of access latch, maybe? part of what triggers autoincrement)
w160     Read enable for DATA
w163     Access to DATA/CTRL
w164     Write command bits 15:8
w165     Write command bits 7:0
w166     Write command bits 7:0 (SMS mode), select upper byte next
w167     Write command bits 15:8? (SMS mode) Write enable for CTRL?
w168     Write command bits 23:16
w169     Write enable for DATA?
w170     Select low byte for next command write (SMS mode) (same as w174 but before RESET is added)
w171     Select low word for next command write?
w174     Select low byte for next command write (SMS mode) (same as w170 but with RESET thrown in)
w175     Select low word for next command write? (same as w171 but with RESET thrown in)
w176     Select high word for next command write? (same as w155 but with RESET thrown in)
w178     CRAM read enable (goes to l623_1 -> l623_2 -> l623_3)
w182     CD5 flag (actually combinatorial and not a latch)
w183     (edge detects a DATA/CTRL access, l21/l22)
w184     ??? Yet another DATA/CTRL access detect? (used by w193 when detecting register writes)
w185     Selects between current (1) or autoincremented (0) address
w186     (part of the logic for w187 and w188, latched through l27)
w187     (not sure but seems to be when writes trigger inside DMA copy?)
w188     (not sure but seems to be when writes trigger outside DMA copy?)
w192     reg_code[1:0] != 2'h2 (not a register write)
w193     Detected a register write? (pipelines to l31..l34,w205)
w199     DMA copy in progress and CD4 set
w201     [not sure how w189 is involved but] Selected VSRAM for reading (goes to l206)
w202     [not sure how w189 is involved but] Selected CRAM for reading
w204     Reset command bits 23:16 (triggered by reset or mode 4)
w205     Register write enable (from l31)
w206     Register 00*** write enable
w207     Register 01*** write enable
w208     Register 10*** write enable (mode 5 required)
w209     Register 01*** write enable (mode 5 required)
w210     Register 01111 ($0F) write enable
w211     Register 10011 ($13) write enable
w212     Register 10100 ($14) write enable
w213     Register 01011 ($0B) write enable
w214     Register 10110 ($16) write enable
w215     Register 01100 ($0C) write enable
w216     Register 00000 ($00) write enable
w217     Register 00001 ($01) write enable
w218     Register 00010 ($02) write enable
w219     Register 00011 ($03) write enable
w220     Register 00100 ($04) write enable
w221     Register 00111 ($07) write enable
w222     Register 10010 ($12) write enable
w223     Register 10001 ($11) write enable
w224     Register 10000 ($10) write enable
w225     Register 00110 ($06) write enable
w226     Register 00101 ($05) write enable
w227     Register 10111 ($17) write enable
w228     Register 10101 ($15) write enable
w229     Register 01010 ($0A) write enable
w230     Register 01001 ($09) write enable
w231     Register 01000 ($08) write enable
w232     Register 01110 ($0E) write enable
w233     Register 01101 ($0D) write enable
w234     Increment DMA source and decrement length by 256 (if reg_test0[1] == 1)
w235     Increment DMA source and decrement length by 1 (if reg_test0[1] == 0)
w244     End of DMA transfer, 1 iteration early?
w245     DMA in progress & reg_dmd == 2'h3 (DMA copy)
w246     DMA in progress & reg_dmd == 2'h1 (DMA transfer from RAM)
w247     DMA in progress & reg_dmd == 2'h0 (DMA transfer from ROM)
w248     DMA in progress & reg_dmd == 2'h2 (DMA fill)
w250     Increment DMA source address
w251     Decrement DMA length (second byte)
w252     Status port FULL bit (0 = FIFO has room, 1 = FIFO is full)
w254     Is FIFO still empty
w255     Increment DMA source address (second byte)
w256     Send entry address from FIFO to VRAM bus (see below)
w257     w256 when FIFO index == 1, sends entry's address to VRAM address bus
w258     w256 when FIFO index == 0, sends entry's address to VRAM address bus
w259     w256 when FIFO index == 3, sends entry's address to VRAM address bus
w260     w256 when FIFO index == 2, sends entry's address to VRAM address bus
w263     Set when DMA fill and FIFO empty
w264     Increment FIFO write index; data write (through DATA port access or DMA transfer)
w267     Set to output DMA source address to CPU address bus (also goes to l5)
w268     Set to output data from FIFO to data bus
w269     Time to flush FIFO entry (free access slot and FIFO not empty) (to l49)
w270     Clears t28 when DMA is over
w271     Sets t28 when a FIFO flush happens while in DMA
w272     [?] Set when DMA fill can proceed? (after the initial write is done) (goes to l50)
w273     68000 and 64KB VRAM and CD2:1 == 0 (not CRAM or VSRAM)
w274     68000 and 64KB VRAM
w276     Upper byte FIFO write strobe (68000 bus)
w277     Upper byte FIFO write (see l55..l58)
w278     Lower byte FIFO write strobe (68000 bus)
w279     Lower byte FIFO write (see l59..l62)
w280     Which FIFO byte is being written in mode 5 (Z80 bus)
w281     [?] DMA copy write to odd address?
w282     [?] DMA copy write to even address?
w283     [?] VRAM write to upper byte?
w284     [?] VRAM write to lower byte?
w285     Lower byte flag OR 64KB VRAM mode
w286     VRAM write to lower byte (goes to VRAM interface block, see w991)
w287     Upper byte flag AND 128KB VRAM mode
w288     VRAM write to upper byte (goes to VRAM interface block, see w999)
w289     Live/FIFO CD flags: VRAM write (CD3:0 == 0001)
w290     FIFO write enable for data
w291     FIFO write enable for 3rd slot data
w292     FIFO write enable for 4th slot data
w293     FIFO write enable for 1st slot data
w294     FIFO write enable for 2nd slot data
w295     Both FIFO indices match, used to detect when FIFO becomes full or empty
w296     Set when incrementing FIFO read index by half entry
w297     Set when incrementing FIFO read index by one entry
w299     ??? (VRAM address write enable? it's clocked too)
w301     CD0 flag & doing an access?
w302     CRAM write enable, upper byte (goes to l601)
w303     CRAM write enable, lower byte (goes to l602)
w304     Updates l94 and l95 (the bytes that are used for FIFO writes)
w305     FIFO read index increment size (0: by half entry, 1: by one entry)
w306     Set when FIFO read index == 3
w307     Set when FIFO read index == 2
w308     Set when FIFO read index == 1
w309     Set when FIFO read index == 0
w310     FIFO CD1 flag for current entry
w311     FIFO upper byte flag for current entry
w312     FIFO CD2 flag for current entry
w313     FIFO lower byte flag for current entry
w314     FIFO CD3 flag for current entry
w315     FIFO CD0 flag for current entry
w316     Live flag or FIFO CD1 flag for current entry
w317     Live flag or FIFO upper byte flag for current entry
w318     Live flag or FIFO CD2 flag for current entry
w319     Live flag or FIFO lower byte flag for current entry
w320     Live flag or FIFO CD3 flag for current entry
w321     Live flag or FIFO CD0 flag for current entry
w322     CD0 from FIFO in mode 5 or CD0 always high in mode 4
w323     VSRAM write, upper byte (goes to l207)
w324     VSRAM write, lower byte (goes to l208)
w325     CD2:1 == 00 (VRAM select) (either live or FIFO, depending on l50)
w326     Sends FIFO entry #3 to VRAM data bus
w327     Sends FIFO entry #1 to VRAM data bus
w328     Sends FIFO entry #0 to VRAM data bus
w329     Sends FIFO entry #2 to VRAM data bus
w330     NOT (68000, 64KB VRAM, CD2:1==00, byte-sized FIFO entry)
w331     Used to select what will go in the low byte of the VRAM write
w332     Upper XOR lower valid byte in FIFO (*not* both)
w333     Set to swap low byte of HV counter port (used to accomodate Z80 bus)
w334     H counter latch freerunning mode
w335     External interrupt pulse (one cycle long!) (goes to l81)
w336     V counter latch enable
w337     H counter latch enable
w338     For w346: set if it's a VRAM read (CD3:2 == 00)
w339     ??? (set when w346 set and VRAM address is even)
w340     ??? (set when w346 set and VRAM address is odd)
w341     Gate latching for upper byte of VRAM read (goes to l88)
w342     Gate latching for lower byte of VRAM read (goes to l89)
w343     Update upper byte of VRAM read
w344     Update lower byte of VRAM read
w345     For w348: selects which VRAM byte to show to the Z80
w346     For w349: selects which VRAM byte is source for upper byte for 68k
w347     Select what to put in low byte when reading HV counter
w348     Lower byte of a DATA read (latched in l92)
w349     Upper byte of a DATA read (latched in l93)
w350     Selects source of upper byte for command write (depending on CPU type)
w351     When outputting to VRAM data bus, selects byte for FIFO entry #0 data (lower byte)
w352     When outputting to VRAM data bus, selects byte for FIFO entry #1 data (lower byte)
w353     When outputting to VRAM data bus, selects byte for FIFO entry #2 data (lower byte)
w354     When outputting to VRAM data bus, selects byte for FIFO entry #3 data (lower byte)
w355     Logical Y coordinate
w356     reg_test1[6:4] == 3'h1 OR 3'h0 and time for plane A tilemap fetch
w357     reg_test1[6:4] == 3'h1
w358     (part of the expression in w359)
w359     Free VRAM slot (CPU access allowed) (latched in l109)
w360     Set if hpos = 258 (H32) or 322 (H40), when F flag is cleared, from l117
w361     Do H counter wraparound
w362     Increment H counter by 1px
w363     Increment H counter by 1px (involves test register #1 bit 3, see w362...)
w364     Value to load when H counter wraps around
w365     (used to compute w364, see above)
w366     (used to compute w364, see above)
w367     (used to compute w364, see above)
w368     (used to compute w364, see above)
w369     (used to compute w364, see above)
w370     From external sync: H counter wraparound
w371     reg_test1[6:4] == 3'h2
w372     reg_test1[6:4] == 3'h2 OR 3'h0 and time for plane B tilemap fetch
w374     vsync
w375     external csync OR external hsync (latter when enabled)
w378     VSRAM timing to use? (reg_vscr ? l124 : ~l117)
w379     w378, but only when reg_test1[6:4] == 3'h0
w380     reg_test1[6:4] == 3'h0
w381     reg_test1[6:4] == 3'h5
w382     reg_test1[6:4] == 3'h3 (forces w385 high)
w383     reg_test1[6:4] == 3'h4 (forces w394 high)
w385     Timing signal: fetch plane A or B tile data (1st half) (from l125)
w386     (part of the expression in w359)
w394     Timing signal: fetch plane A or B tile data (2nd half) (from l126)
w395     (part of the expression in w359)
w396     Hsync (for current mode)
w401     Start of hblank OR reset
w403     ??? (just merges w410 with its delayed signal)
w404     Hsync gated by hsync dir bit (comes from w396)
w410     w361 (H counter wraparound) & w416 (???)
w411     External hsync, when enabled by reg $0C (gated from l149)
w414     H Timing signal: start of equalization pulse
w416     ~reg_8c_b4 & reg_80_b0 (related to sprites?)
w419     Lets you force hscroll table fetch when reg_test1[6:4] == 3'h5
w421     ??? Hsync for mode 4? Selects something depending on w427 (reg $00 bit 3 set in mode 5)
w422     Status port HB bit (0 = not in hblank, 1 = in hblank)
w423     H Timing signal: start of hsync
w425     w416 & ~reg_81_b0 => ~reg_8c_b4 & reg_80_b0 & ~reg_81_b0 (related to sprites?)
w427     ??? Reg $00 bit 3 set in mode 5 (isn't it unused there?)
w428     Value to use V counter when it wraps around
w429     (used to compute w428, see above)
w430     (used to compute w428, see above)
w431     (used to compute w428, see above)
w432     (used to compute w428, see above)
w433     (used to compute w428, see above)
w434     (used to compute w428, see above)
w435     (used to compute w428, see above)
w436     Do V counter increment
w437     Do V counter wraparound
w439     Status port VB bit (0 = active scan, 1 = passive scan)
w446     Status port ODD bit (0 = even field, 1 = odd field)
w457     Start of vblank (opposite of w469, latched from l170), also latches interlaced mode
w458     Reset OR start of vblank
w466     Opposite of w439 (1 = active scan, 0 = passive scan)
w467     V Timing signal: V counter wraparound point
w468     V Timing signal: (low logic) end of vblank / start of vertical visible area
w469     V Timing signal: (low logic) start of vblank / end of vertical visible area
w470     V Timing signal: end of bottom border / start of bottom TV blank
w471     V Timing signal: start of top border / end of top TV blank
w472     V Timing signal: start of vsync (always 3 lines before w473)
w473     V Timing signal: end of vsync / start of top TV vblank
w474     V Timing signal: ??? (always 3 lines after w473, end of the extra sync pulses maybe?)
w475     V Timing signal: (low logic) line 511
w476     H Timing signal: refresh slot (goes to l108)
w477     H Timing signal: fetch plane A tilemap data
w478     H Timing signal: fetch plane B tilemap data
w479     H Timing signal: fetch plane A or B tile data (1st half)
w480     H Timing signal: fetch plane A or B tile data (2nd half)
w481     H Timing signal: fetch sprite X and tile ID
w482     H Timing signal: fetch sprite tile (fed into l141)
w483     H Timing signal: odd pixels (for what is this used?)
w484     H Timing singal: m4 sprite tile fetch (1st half)
w485     H Timing signal: m4 sprite X / tile ID fetches? (active scan only, passive scan is weird) (to l155)
w486     H Timing signal: m4 sprite Y fetches?
w487     H Timing signal: m4 fetch sprite Y data???, m5 scan sprite Y data? (fed into l147)
w488     H Timing signal: ??? (fetch hscroll table?)
w493     H Timing signal: start of horizontal display (end of left border)
w494     H Timing signal: end of horizontal display (start of right border)
w495     H Timing signal: start of hblank
w496     H Timing signal: end of hblank
w499     H Timing signal: end of equalization pulse (11px early?)
w500     H Timing signal: start of hsync (11px early), start of back porch (2px early)
w501     H Timing signal: end of hsync (11px early)
w502     H Timing signal: increment V counter (low logic)
w504     H Timing signal: H counter = 0
w505     H Timing signal: VSRAM read in full vscroll? (low logic), when F flag is cleared in SMS mode
w506     H Timing signal: VSRAM read in column vscroll? (H counter is multiple of 8px (0, 8, 16, 24...504))
w507     H Timing signal: H counter multiple of 8px + 7 (mode 4), multiple of 16px + 7 (mode 5)
w508     H Timing signal: H counter multiple of 16px + 15
w510     H Timing signal: 3px after sprite X & tile ID fetch in mode 5 (to l145)
w512     H Timing signal: H counter multiple of 16px + 3
w515     VScroll value to work with (VSRAM output in mode 5, register $09 in mode 4)
w516     Set to latch a VSRAM read into l180
w519     Clear when vscroll inhibit should kick in, set otherwise
w522     Y coordinate to access in the tilemap (before interlaced mode adjustment)
w523     Set if plane A/B size is 32 tiles (reg_hsz == 2'h0)
w524     Set if plane A/B size is 64 tiles (reg_hsz == 2'h1)
w525     Set if plane A/B size is 128 tiles (reg_hsz == 2'h3)
w526     Y coordinate to access in the tilemap (before wraparound, accounting for IM2)
w527     Offset to access in the tilemap (X and Y merged)
w528     Actual Y coordinate to access in the tilemap (see w527)
w529     Same as w530 (see below) in mode 4, forced to 0 in mode 5 (used for calculating w528)
w530     Do Y scroll wraparound? (for mode 4, goes to w529)
w531     Set to output tilemap fetch address bits 16:14 on VRAM address bus
w532     Plane address bits 16:13 (put on VRAM bus) / Either m5 plane A or B address bits 16:13 (depending on l200)
w533     Plane address bits 12:11 (put on VRAM bus) / Either (m4) plane A or (m5) address bits 12:11
w534     Set when H counter is not within 384..511
w535     Hscroll line to read (after applying hscroll mode bits)
w536     X offset within window tilemap (accounts for H32 or H40)
w537     Which hscroll line to fetch? (drops LSB of logical Y coordinate, should match l105[7:0])
w542     Latch window X register (into l187 and l188)
w543     Latch window Y register (w/o test register, into w544)
w544     Latch window Y register (into l189 and l190)
w545     Which side of window Y split? (1: above, 0: below)
w546     Which side of window X split? (0: left, 1: right)
w547     V counter increment OR test reg1 b7 (same as w542)
w552     Set if hscroll inhibit should kick in (in mode 4)
w553     Clear to latch hscroll for plane A in mode 4
w554     Hscroll value to use when fetching, INVERTED (i.e. NOT'd)
w555     Actual X coordinate to access in the tilemap (upper bits used in w527, lower bits in VRAM address bus)
w558     Set to output tilemap fetch address bits 13:0 on VRAM address bus
w561     Set if in left/right border (H32: H counter >= 256; H40: >= 320)
w562     Set if in viewport horizontally and in mode 4
w563     Set if w562 and odd tile (H counter = multiple of 16px + 8px)
w565     In viewport horizontally: current 16px column; in border: 4'b1111
w566     VRAM address output enable: bits 16:14 of plane A/B tile fetch
w568     H counter >= 320
w569     Set on VSRAM bus access
w570     Set to latch from VRAM to plane A hscroll bits 7:0 (see l191)
w571     Set to latch from VRAM to plane A hscroll bits 9:8 (see l194)
w572     Set to latch from VRAM to plane B hscroll bits 7:0 (see l192)
w573     Set to latch from VRAM to plane B hscroll bits 9:8 (see l195)
w574     Set to use hscroll for plane A in mode 5
w575     Set to use hscroll for plane B in mode 5
w576     Bits 4:2 of plane A/B tile address to fetch before vflip
w577     Bits 4:2 of plane A/B tile address to fetch
w578     Bits 13:5 of plane A/B 1st tile address to fetch
w579     Bits 16:14 of plane A/B 1st tile address to fetch
w580     Bits 16:5 of plane A/B 2nd tile address to fetch
w581     Mux: plane A or B tile bank (address MSB)
w583     *Actual* plane A/B vflip flag in effect (I think it throws in test register?)
w584     Plane A/B hflip flag (read from VRAM), adjusted for mode 4/5
w585     Plane A/B vflip flag (read from VRAM), adjusted for mode 4/5
w586     Plane A/B palette flags (read from VRAM), adjusted for mode 4/5
w587     Plane A/B priority flag (read from VRAM), adjusted for mode 4/5
w592     ??? (copies l223..l226 to l232..l235, l243..l246 to l255..l258, l259 to l260 when set)
w606     Which pixel within a tile to show for plane A
w607     Plane A color index to show (to l269)
w611     ??? (copies l232..l235 to l237..l240, l260 to l265 when set)
w615     Set to latch lower byte of plane A/B 1st tilemap fetch
w616     Set to latch upper byte of plane A/B 1st tilemap fetch
w617     Set to latch lower byte of plane A/B 2nd tilemap fetch
w618     Set to latch upper byte of plane A/B 2nd tilemap fetch
w619     [???] (set to latch 1st byte of something into l278, tile fetch?)
w620     [???] (set to latch 2nd byte of something into l277, tile fetch?)
w621     [???] (set to latch 3rd byte of something into l276, tile fetch?)
w622     [???] (set to latch 4th byte of something into l275, tile fetch?)
w623     NOT column vscroll (i.e. mode 5 full vscroll or mode 4)
w624     Set if H counter is multiple of 16px if full vscroll, or if offset +8 if column vscroll
w625     Vscroll column to read from VSRAM
w626     VSRAM addres to access (goes to l212)
w640     [???] (set to start the sequence for w619..w622)
w641     Which pixel of plane B tile to show? (0 to 7)
w642     Lets you force a hscroll table fetch when reg_test1[7] == 1 and HL
w646     Set if plane A is opaque
w647     Plane B color index to show (to l318)
w648     Set if plane B is opaque
w655     Set if sprite link == 127 (inverted?)
w656     Sprite height bit 1?
w657     Sprite height bit 0?
w663     Set if sprite height == 1 tile
w664     Set if sprite height == 3 tiles
w683     Set to load next sprite link (in mode 5) into sprite ID (l351)
w684     Set to output sprite table offset for sprite Y in VRAM address bus in mode 4, also increments sprite ID (l351)
w687     Set to latch 4th byte of cacheable sprite entry (link)
w688     Set to latch 3rd byte of cacheable sprite entry (size)
w689     Set to latch 1st byte of cacheable sprite entry (Y bits 9:8)
w690     Set to latch 2nd byte of cacheable sprite entry (Y bits 7:0)
w693     Is VRAM address within sprite cache range (upper byte) (goes to l363)
w694     Is VRAM address within sprite cache range (lower byte) (goes to l364)
w695     [???] SAT index to read?
w696     Sprite index to access (to l398)
w705     reg_test_18[6:5] == 2 (low logic) Use latched sprite [other] for w770
w706     reg_test_18[6:5] == 1 (low logic) Use latched sprite pattern l425 for w770
w707     reg_test_18[6:5] == 0 (low logic) Use latched sprite X coordinate for w770
w717     (part of w738 logic, test register use only)
w732     [???] (from w738, throws in more test register stuff)
w738     [???] w717 when reg_test0[14] == 0
w740     Is VRAM address within sprite table range
w741     Is VRAM address within sprite cache range
w742     Timing signal: sprite tile fetch for mode 4 (enables VRAM bus)
w751     Timing signal: sprite tile fetch for mode 4 (unfilitered, goes to w742)
w752     Sprite index to access (from l400, latched to l403..l409)
w754     Timing signal: sprite table fetch for mode 4? (l411 and l412, enables VRAM bus)
w755     Timing signal: sprite table fetch for mode 4? (l412 only)
w756     Timing signal: sprite table fetch for mode 5? (enables VRAM bus)
w757     Bottom 7 bits of mode 5 sprite table address to access
w759     [???] l426 & reg_test0[12] (related to source of sprite X? what's l426?)
w760     [???] l426 & ~reg_test0[12] (related to source of sprite X? what's l426?)
w770     Debug: sprite metadata (yoffset[2:0],height[1:0],width[1:0],pri,pal[1:0],hflip), pattern or X
w771     [???] Set if sprite with is 4 tiles?
w772     [???]
w776     [???] ~(~reg_m5 | w772)
w781     Sprite tile fetch for mode 5 (sets l428 which enables VRAM bus)
w782     [???] Set if sprite X is not 0
w809     in M4 = H counter + $1F4 + 1, in M5 = H counter + $1ED + 1
w817     Line buffer write enable (global)
w819     hclk2 only if display enabled (low logic)
w825     Line buffer address
w910     Line buffer write enable pixel #0
w911     Line buffer write enable pixel #1
w912     Line buffer write enable pixel #2
w913     Line buffer write enable pixel #3
w914     Line buffer write enable pixel #4
w915     Line buffer write enable pixel #5
w916     Line buffer write enable pixel #6
w917     Line buffer write enable pixel #7
w918     Old sprite data pixel #0 opaque
w919     Old sprite data pixel #1 opaque
w920     Old sprite data pixel #2 opaque
w921     Old sprite data pixel #3 opaque
w922     Old sprite data pixel #4 opaque
w923     Old sprite data pixel #5 opaque
w924     Old sprite data pixel #6 opaque
w925     Old sprite data pixel #7 opaque
w934     New sprite data pixel #0 opaque
w935     New sprite data pixel #1 opaque
w936     New sprite data pixel #2 opaque
w937     New sprite data pixel #3 opaque
w938     New sprite data pixel #4 opaque
w939     New sprite data pixel #5 opaque
w940     New sprite data pixel #6 opaque
w941     New sprite data pixel #7 opaque
w942     Can sprite pixel #0 be rewritten?
w943     Can sprite pixel #1 be rewritten?
w944     Can sprite pixel #2 be rewritten?
w945     Can sprite pixel #3 be rewritten?
w946     Can sprite pixel #4 be rewritten?
w947     Can sprite pixel #5 be rewritten?
w948     Can sprite pixel #6 be rewritten?
w949     Can sprite pixel #7 be rewritten?
w950     Always 0, would have selected between sprite underdraw or overdraw
w951     ~w820
w952     reg_test_18[7:6] == 2'h0 (debug, selects a pair of sprite layer pixels?)
w953     reg_test_18[7:6] == 2'h1 (debug, selects a pair of sprite layer pixels?)
w954     reg_test_18[7:6] == 2'h2 (debug, selects a pair of sprite layer pixels?)
w955     reg_test_18[7:6] == 2'h3 (debug, selects a pair of sprite layer pixels?)
w956     Palette bit 0 of chosen sprite layer pixel (even)
w957     Palette bit 1 of chosen sprite layer pixel (even)
w958     Priority bit of chosen sprite layer pixel (even)
w959     Color bit 0 of chosen sprite layer pixel (even)
w960     Color bit 1 of chosen sprite layer pixel (even)
w961     Color bit 2 of chosen sprite layer pixel (even)
w962     Color bit 3 of chosen sprite layer pixel (even)
w963     Palette bit 0 of chosen sprite layer pixel (odd)
w964     Palette bit 1 of chosen sprite layer pixel (odd)
w965     Priority bit of chosen sprite layer pixel (odd)
w966     Color bit 0 of chosen sprite layer pixel (odd)
w967     Color bit 1 of chosen sprite layer pixel (odd)
w968     Color bit 2 of chosen sprite layer pixel (odd)
w969     Color bit 3 of chosen sprite layer pixel (odd)
w970     Sprite layer palette from line buffer? (affected by mode 5, involves a latch and "spr_pal")
w971     Sprite layer priority from line buffer? (affected by mode 5, involves a latch and "spr_priority")
w972     Sprite layer color from line buffer? (affected by mode 5, involves a latch and "spr_index")
w973     Final sprite layer priority (forced to 0 in mode 4, used in layer mixing)
w974     Final sprite palette (forced to 01 in mode 4, used in layer mixing)
w975     l556 == 2'h3 (sprite S/H palette check?)
w976     l558 != 4'h0 (sprite not transparent pixel check?)
w977     l558 == 4'hE (sprite S/H highlight pixel check?)
w978     l558 == 4'hF (sprite S/H shadow pixel check?)
w979     Line buffer write data priority (odd?)
w980     Line buffer write data palette (odd?)
w982     Line buffer write data priority (even?)
w983     Line buffer write data palette (even?)
w985     VRAM read enable (high logic)
w986     VRAM lower byte write enable (high logic), goes to /WE0 (as low logic)
w987     VRAM upper byte write enable (high logic), goes to /WE1 (as low logic)
w990     Control pin direction of RD and AD (0: output, 1: input, I think?)
w991     VRAM write to lower byte (from w286, or l571 which is latched w286)
w999     VRAM write to upper byte (from w288, or l585 which is latched w288)
w1007    Alternate between /SE0 and /SE1 in 128k mode, or stick to /SE0 only when not 128k
w1009    /YS signal (see w1082 too)
w1010    Used for VRAM address computation (bit 1 in m5)
w1011    Used for VRAM address computation (w1010 OR bit 9 in m4)
w1012    Physical VRAM address (upper half, latched into l592)
w1013    VRAM address MSB to use
w1014    Physical VRAM address (lower half, latched into l593)
w1018    VRAM address bus output (connected to AD_o[7:0])
w1019    VRAM data bus output (connected to RD_o[7:0])
w1021    Set on CRAM bus access
w1022    [layer mux block]  a_pri ?  s_pri : ~b_pri
w1023    [layer mux block] ~a_pri &  s_pri &  b_pri
w1024    [layer mux block]  a_pri & ~s_pri & ~b_pri
w1025    [layer mux block] ~a_pri & ~s_pri &  b_pri
w1026    [layer mux block]  a_pri & ~s_pri &  b_pri
w1027    [layer mux block] ~a_pri & ~s_pri & ~b_pri & S/H enable
w1028    [layer mux block] ~a_pri &  s_pri & ~b_pri & S/H enable
w1029    S/H enable
w1030    Is it a S/H sprite pixel?
w1031    Is it a S/H sprite pixel OR no sprite pixel?
w1032    Set if plane A layer is transparent in this pixel
w1033    Set if plane B layer is transparent in this pixel
w1034    reg_test0[8:7] == 2'h1; (layer override: sprite)
w1035    reg_test0[8:7] == 2'h2; (layer override: plane A)
w1036    reg_test0[8:7] == 2'h3; (layer override: plane B)
w1037    reg_test0[8:7] == 2'h0; (layer override: none)
w1044    Set to output sprite plane to color bus (goes to l603)
w1050    Set to output plane A to color bus (goes to w1051)
w1051    Set to output plane A to color bus (after override is applied, goes to l604)
w1057    Set to output plane B to color bus (goes to w1058)
w1058    Set to output plane B to color bus (after override is applied, goes to l605)
w1061    Set to output background plane to color bus (goes to l606)
w1065    Shadow or highlight pixel color index (part of w1030's expression)
w1069    ??? (affected by layer override enable, involves BG color bit 6)
w1070    ??? (affected by layer override enable, involves BG color bit 7)
w1072    CRAM CPU access in mode 5?
w1073    CRAM CPU access in mode 4?
w1074    ??? (involves SPA/B)
w1075    CRAM data bus? (delay line?)
w1076    CRAM address to access (goes to l617)
w1077    Set if output color is transparent (latched in l619)
w1078    CRAM write: data for "red" bits (internal bits 2:0)
w1079    CRAM write: data for "green" bits (internal bits 5:3)
w1081    Enable color output on RGB pins (goes to l624)
w1082    Set when displaying background color (ignoring SPA/B)
w1083    Red color bit 1 (mux for m4/m5)
w1084    Red color bit 2 (mux for m4/m5)
w1085    Green color bit 1 (mux for m4/m5)
w1086    Green color bit 2 (mux for m4/m5)
w1087    Blue color bit 1 (mux for m4/m5)
w1088    Blue color bit 2 (mux for m4/m5)
w1089    Red color bit 1 masked by M4
w1090    Red color bit 2 masked by M4
w1091    Green color bit 1 masked by M4
w1092    Green color bit 2 masked by M4
w1093    Blue color bit 1 masked by M4
w1094    Blue color bit 2 masked by M4
w1098    Blue color bit 0 masked by M5
w1099    Green color bit 0 masked by M5
w1100    Red color bit 0 masked by M5
w1101    Normal color flag (see l630 for highlight)
w1102    Shadow color flag (see l630 for highlight)
w1103    Goes to the RGB DAC taps ([0] = red, [1] = green, [2] = blue)
w1112    reg_test0[9] & reg_test0[11:10] != 2'h0 (PSG channel override: ch1)
w1113    reg_test0[9] & reg_test0[11:10] != 2'h1 (PSG channel override: ch2)
w1114    reg_test0[9] & reg_test0[11:10] != 2'h2 (PSG channel override: ch3)
w1115    reg_test0[9] & reg_test0[11:10] != 2'h3 (PSG channel override: ch4)

dff3_l2  DMA in progress
dff22_l2 DMA transfer in progress (latched from t4)
dff23_l2 ??? (bit 0 of some value, incremented by ~t3, reset by w41)
dff24_l2 ??? (bit 1 of some value, incremented by ~t3, reset by w41)
dff25_l2 ??? (bit 2 of some value, incremented by ~t3, reset by w41)
dff26_l2 ??? (bit 3 of some value, incremented by ~t3, reset by w41)
dff27_l2 ??? (bit 4 of some value, incremented by ~t3, reset by w41)
dff28_l2 ??? (bit 5 of some value, incremented by ~t3, reset by w41)
dff29_l2 ??? (bit 6 of some value, incremented by ~t3, reset by w41)
dff30_l2 Pending external interrupt? (set by w58, reset by w49)
dff31_l2 Pending hblank interrupt? (set by w57, reset by w49)
dff32_l2 Pending vblank interrupt? (set by w60, reset by w49)

l1       H Timing signal: refresh slot (from l108, introduces 2 cycles of latency)
l2       H Timing signal: refresh slot (from l1, introduces 3 cycles of latency)
l3       H Timing signal: refresh slot (from l2, introduces 4 cycles of latency)
l4       Set during a refresh slot for 4 cycles
l5       Used to ensure that w267 is stable
l6       ??? (affects output of MSB of source address in DMA transfer from ROM)
l7       (pipeline from l6, to l8)
l8       (pipeline from l7)
l9       End of interrupt acknowledge (from w48, to l10)
l10      End of interrupt acknowledge (from l9, to l11)
l11      End of interrupt acknowledge (from l10)
l12      [has another use with w51] Used to reset t6 two cycles after it's set (t6 -> l12 -> l13)
l13      [has another use with w52] Used to reset t6 two cycles after it's set (t6 -> l12 -> l13)
l14      Clear sprite overflow and collision flags on vblank
l18      Select between DATA and CTRL port for writes
l19      Select between DATA and CTRL port for reads (used by w143)
l21      Latch pipeline during access to DATA/CTRL? (pipeline, from l22)
l22      Latch pipeline during access to DATA/CTRL? (pipeline, from l23 to l21)
l23      Latch pipeline during access to DATA/CTRL? (pipeline, from l24 to l22)
l24      Latch pipeline during access to DATA/CTRL? (pipeline, from l25 to l23)
l25      Latch pipeline during access to DATA/CTRL? (pipeline, from t13 to l24)
l31      Register write enable pipeline (from l34, to w205)
l32      Register write enable pipeline (from w193, to l33 and l34)
l33      Register write enable pipeline (from l32, to l34)
l34      Register write enable pipeline (from l32 and l33, to l31)
l35      Current VRAM address (17-bit)
l36      FIFO address entry #1 (17-bit)
l37      FIFO address entry #0 (17-bit)
l38      FIFO address entry #3 (17-bit)
l39      FIFO address entry #2 (17-bit)
l40      (used to ensure that the w18 pulse is stable)
l43      Set when FIFO is full
l45      (used for rising edge detection of l44)
l46      Status port EMPT bit (0 = FIFO has data, 1 = FIFO is empty)
l47      ??? (stores VRAM address bit 0)
l48      Finish DMA transfer (from w244, to w4)
l49      Time to flush FIFO entry (free access slot and FIFO not empty) (from w269)
l50      Selects between live flags and FIFO flags (used during DMA fill) (from w272)
l51      FIFO write index (2-bit)
l52      FIFO read index (bit -1, yes "half" an entry)
l53      FIFO read index (bit 0)
l54      FIFO read index (bit 1)
l55      FIFO upper byte OK entry #3 (stores w277)
l56      FIFO upper byte OK entry #2 (stores w277)
l57      FIFO upper byte OK entry #1 (stores w277)
l58      FIFO upper byte OK entry #0 (stores w277)
l59      FIFO lower byte OK entry #3 (stores w279)
l60      FIFO lower byte OK entry #2 (stores w279)
l61      FIFO lower byte OK entry #1 (stores w279)
l62      FIFO lower byte OK entry #0 (stores w279)
l63      FIFO CD0 entry #3
l64      FIFO CD0 entry #2
l65      FIFO CD0 entry #1
l66      FIFO CD0 entry #0
l67      FIFO CD1 entry #3
l68      FIFO CD1 entry #2
l69      FIFO CD1 entry #1
l70      FIFO CD1 entry #0
l71      FIFO CD2 entry #3
l72      FIFO CD2 entry #2
l73      FIFO CD2 entry #1
l74      FIFO CD2 entry #0
l75      FIFO CD3 entry #3
l76      FIFO CD3 entry #2
l77      FIFO CD3 entry #1
l78      FIFO CD3 entry #0
l79      Lightgun input (to l80, used for edge detection)
l80      Lightgun input (from l79, used for edge detection)
l81      External interrupt pulse (one cycle long!) (from w335)
l83      VRAM address bit 0? (comes from l47)
l84      VRAM address bit 0? (comes from l83 <- l47)
l85      VRAM address bit 0? (comes from l84 <- l83 <- l47)
l88      Gate latching for upper byte of VRAM read (from w341)
l89      Gate latching for lower byte of VRAM read (from w342)
l90      Frozen V counter (exposed over $C00008)
l91      Frozen H counter (exposed over $C00009)
l92      Lower byte of a DATA read (latched from w348)
l93      Upper byte of a DATA read (latched from w349)
l94      Value to write to FIFO entry data (upper byte)
l95      Value to write to FIFO entry data (lower byte)
l96      FIFO entry #0 data (upper byte)
l97      FIFO entry #0 data (lower byte)
l98      FIFO entry #1 data (upper byte)
l99      FIFO entry #1 data (lower byte)
l100     FIFO entry #2 data (upper byte)
l101     FIFO entry #2 data (lower byte)
l102     FIFO entry #3 data (upper byte)
l103     FIFO entry #3 data (lower byte)
l104     ??? (latch for data to write? used in a lot of places)
l105     V counter
l106     H counter
l108     H Timing signal: refresh slot (from w476, introduces 1 cycle of latency)
l109     Free VRAM slot (CPU access allowed) (latched from w359)
l112     H Timing signal: H counter wraparound (from w490, introduces 1 cycle of latency)
l113     Used to do edge detection of l121
l115     H Timing signal: increment V counter (from w502, turned high logic), latch window settings
l117     H Timing signal: VSRAM read in full vscroll, when F flag is cleared (from w505)
l118     H Timing signal: fetch plane A tilemap data (from w477)
l119     H Timing signal: fetch plane B tilemap data (from w478)
l120     CSYNC pin input
l121     ??? (whatever w376 is)
l122     H Timing signal: (whatever w492 is, goes to l173)
l123     H Timing signal: end of hsync
l124     H Timing signal: VSRAM read in column vscroll (from w506)
l125     H Timing signal: fetch plane A or B tile data (1st half) (from w479)
l126     H Timing signal: fetch plane A or B tile data (2nd half) (from w480)
l129     HBLANK flag in mode 4
l134     H Timing signal: fetch sprite table data (see w481)
l135     ??? (Hsync for mode 5? I got lost...)
l136     Hsync? (high logic)
l137     H Timing signal: end of horizontal display (start of right border) (see w494)
l138     H Timing signal: end of equalization pulse (see w499)
l141     H Timing signal: fetch sprite tile (see w482)
l143     H Timing signal: start of hblank (see w495)
l144     H Timing signal: (whatever w498 is)
l145     H Timing signal: 3px after sprite X & tile ID fetch in mode 5 (from w510)
l146     H Timing signal: (whatever w509 is)
l147     H Timing signal: m4 fetch sprite Y data, m5 scan sprite Y data? (see w487)
l148     H Timing signal: hscroll table fetch (pipeline goes to l316)
l149     External HSync pin input
l152     End of hblank
l155     H Timing signal: m4 sprite X / tile ID fetches? (active scan only, passive scan is weird) (from w485)
l156     H Timing signal: (whatever w484 is)
l158     HBLANK flag in mode 5 (delayed by one cycle compared to mode 4 l129)
l162     V Timing signal: line 511 (from w475, turned high logic)
l163     V Timing signal: ??? (always 3 lines after w473, end of the extra sync pulses maybe?) (from w474)
l164     V Timing signal: end of vsync / start of top TV vblank (from w473)
l165     V Timing signal: start of vsync (always 3 lines before w473) (from w472)
l167     V Timing signal: start of top border / end of top TV blank (from w471)
l170     Not start of vblank (from w469)
l173     H Timing signal: (whatever w492 is, from l122)
l178     Bit 3 of H counter (related to tilemap fetches?)
l179     Register $09 (mode 4 vscroll)
l180     Holds data read from VSRAM bus (updated when w516 goes high)
l181     Data to write to VSRAM
l182     Data to write to VSRAM (bits 10:8, goes to l181)
l183     Enables VSRAM output to the VRAM bus
l184     VScroll value to work with (VSRAM output in mode 5, register $09 in mode 4) (from w515, latched when w517)
l187     Latches window left/right split select (copied from reg $11 on w542)
l188     Latches window X split position (copied from reg $11 on w542)
l189     Latches window up/down split select (copied from reg $12 on w544)
l190     Latches window Y split position (copied from reg $12 on w544)
l191     Bits 7:0 of horizontal scroll in mode 5 for plane A
l192     Bits 7:0 of horizontal scroll in mode 5 for plane B
l193     Horizontal scroll in mode 4 (copied from reg $08)
l194     Bits 9:8 of horizontal scroll in mode 5 for plane A
l195     Bits 9:8 of horizontal scroll in mode 5 for plane B
l196     VRAM address output enable: bits 4:0 of plane A/B tile fetch
l197     Fetching plane A (0) or plane B (1)?
l198     Bit 1 of plane A/B tile address to fetch (inverted)
l199     VRAM address output enable: bits 13:5 of plane A/B tile fetch
l202     [???] (there's window tilemap fetch on VRAM bus)
l203     (pipeline, goes to l204)
l204     (pipeline, goes to l205)
l205     Set to start fetching of tilemap table data (see l251)
l206     VSRAM read enable (from w201, to l209)
l207     VSRAM write enable, upper byte (from w323, to l210)
l208     VSRAM write enable, lower byte (from w324, to l211)
l209     VSRAM read enable (from l206, to w516)
l210     VSRAM write enable, upper byte (bits 10:8)
l211     VSRAM write enable, lower byte (bits 7:0)
l212     VSRAM address to access (from w626)
l213     Set while fetching hscroll plane A bits 7:0 (see w570)
l214     Set while fetching hscroll plane A bits 9:8 (see w571)
l215     Set while fetching hscroll plane B bits 7:0 (see w572)
l216     Set while fetching hscroll plane B bits 9:8 (see w573)
l219     Plane A/B 1st tilemap fetch lower byte
l220     Plane A/B 1st tilemap fetch upper byte
l221     Plane A/B 2nd tilemap fetch lower byte
l222     Plane A/B 2nd tilemap fetch upper byte
l236     [???] Amount to shift plane to the right? (loaded with bits 3:0 of hscroll)
l237     Plane B tile pixels 7:6
l238     Plane B tile pixels 5:4
l239     Plane B tile pixels 3:2 (m5), plane A bitplane 3 (m4)
l240     Plane B tile pixels 1:0 (m5), plane A bitplane 2 (m4)
l241     [???] X offset within plane (A?) output? (loaded with l236; counts up every dot)
l251     Set while fetching tilemap data (1st tile) bits 7:0 (see w615)
l252     Set while fetching tilemap data (1st tile) bits 15:8 (see w616)
l253     Set while fetching tilemap data (2nd tile) bits 7:0 (see w617)
l254     Set while fetching tilemap data (2nd tile) bits 15:8 (see w618)
l261     Plane A tile pixels 7:6
l262     Plane A tile pixels 5:4
l263     Plane A tile pixels 3:2 (m5), plane A bitplane 1 (m4)
l264     Plane A tile pixels 1:0 (m5), plane A bitplane 0 (m4)
l269     Plane A color index to show (from w607, to l270)
l270     Plane A color index to show (from l269, to color bus)
l271     Plane A color palette to show (from w604;w603, to l272)
l272     Plane A color palette to show (from l271, to color bus)
l273     Plane A priority to show (from w605, to l274 and mux block)
l274     Plane A priority to show (from l273, to color bus)
l275     Plane B 1st tile 4th byte latch (from VRAM, may be byteswapped?)
l276     Plane B 1st tile 3rd byte latch (from VRAM, may be byteswapped?)
l277     Plane B 1st tile 2nd byte latch (from VRAM, may be byteswapped?)
l278     Plane B 1st tile 1st byte latch (from VRAM, may be byteswapped?)
l293     VRAM address bits 6:1 (used in VSRAM block)
l294     Plane B 2nd tile 4th byte latch (from VRAM, may be byteswapped?)
l295     Plane B 2nd tile 3rd byte latch (from VRAM, may be byteswapped?)
l296     Plane B 2nd tile 2nd byte latch (from VRAM, may be byteswapped?)
l297     Plane B 2nd tile 1st byte latch (from VRAM, may be byteswapped?)
l311     [???] X offset within plane (B?) output? (loaded with l236, MSB inverted; counts up every dot)
l314     (pipeline, goes to l315)
l315     (pipeline, goes to l316)
l316     Set to start fetching of hscroll table data (see l213)
l318     Plane B color index to show (from w647, to l319)
l319     Plane B color index to show (from l318, to color bus)
l320     Plane B priority to show (from w637, to l321 and mux block)
l321     Plane B priority to show (from l320, to color bus)
l322     Plane B color palette to show (from w636;w635, to l323)
l323     Plane B color palette to show (from l322, to color bus)
l327     (see l328 -> l332)
l328     (see l332)
l332     { sat_size, sat_link }
l351     Current sprite ID being processed
l352     Used to stretch out l353 one cycle longer
l363     Is VRAM address within sprite cache range (upper byte) (from w693)
l364     Is VRAM address within sprite cache range (lower byte) (from w694)
l398     Sprite index to access (from w696, to l399)
l399     Sprite index to access (from l398, to l400)
l400     Sprite index to access (from l399, to l403..l409 via w752)
l403     Sprite index to read, bit 0 (from l400 via w752, to w757); 20 (H40) or 16 (H32) entries
l404     Sprite index to read, bit 1 (from l400 via w752, to w757); 20 (H40) or 16 (H32) entries
l405     Sprite index to read, bit 2 (from l400 via w752, to w757); 20 (H40) or 16 (H32) entries
l406     Sprite index to read, bit 3 (from l400 via w752, to w757); 20 (H40) or 16 (H32) entries
l407     Sprite index to read, bit 4 (from l400 via w752, to w757); 20 (H40) or 16 (H32) entries
l408     Sprite index to read, bit 5 (from l400 via w752, to w757); 20 (H40) or 16 (H32) entries
l409     Sprite index to read, bit 6 (from l400 via w752, to w757); 20 (H40) or 16 (H32) entries
l413     Sprite hflip latch
l414     Sprite palette latch
l415     Sprite priority latch
l416     Sprite width latch
l417     Sprite height latch
l418     Sprite Y offset latch
l420     Sprite width latch *negated*
l424     Sprite pattern latch
l425     Sprite X coordinate latch
l426     [???] (gates something related to sprite X coordinate?)
l428     [???] (there's mode 5 sprite tile fetch on VRAM bus)
l523     Line buffer write data color #0
l524     Line buffer write data color #1
l525     Line buffer write data color #2
l526     Line buffer write data color #3
l527     Line buffer write data color #4
l528     Line buffer write data color #5
l529     Line buffer write data color #6
l530     Line buffer write data color #7
l538     Line buffer write enable pixel #0 (from w910, before clock)
l539     Line buffer write enable pixel #1 (from w911, before clock)
l540     Line buffer write enable pixel #2 (from w912, before clock)
l541     Line buffer write enable pixel #3 (from w913, before clock)
l542     Line buffer write enable pixel #4 (from w914, before clock)
l543     Line buffer write enable pixel #5 (from w915, before clock)
l544     Line buffer write enable pixel #6 (from w916, before clock)
l545     Line buffer write enable pixel #7 (from w917, before clock)
l553     [???] (somehow related to w970 and l556, part of a delay line?)
l554     [???] (somehow related to w971 and l557, part of a delay line?)
l555     [???] (somehow related to w972 and l558, part of a delay line?)
l556     [???] (related to S/H?, latches w970's value)
l557     [???] (related to S/H?, latches w971's value)
l558     [???] (related to S/H?, latches w972's value)
l571     VRAM write to upper byte (latched from w286, goes to w991)
l574     (use unknown?) Free VRAM slot (CPU access allowed) (latched from l109)
l585     VRAM write to lower byte (latched from w288, goes to w999)
l586     0: enable 1st VRAM (/SE0), 1: enable 2nd VRAM (/SE1)
l592     Physical VRAM address (upper half, latched from w1012)
l593     Physical VRAM address (lower half, latched from w1014)
l600     Set sprite collision flag
l601     CRAM write, upper byte (latched from w302)
l602     CRAM write, lower byte (latched from w303)
l603     Show sprite plane (from w1044, goes to color bus)
l604     Show plane A (from w1051, goes to color bus)
l605     Show plane B (from w1058, goes to color bus)
l606     Show background plane (from w1061, goes to color bus)
l615     SPA/B pin's input (logic reversed from pin!)
l617     CRAM address to access (from w1076)
l619     Set if output color is transparent (latched from w1077, goes to l625)
l620     CRAM write: data for "blue" bits (internal bits 8:6)
l622     Latched RGB color to output (BBBGGGRRR or xxxBBGGRR)
l624     Enable color output on RGB pins (from w1081)
l625     Set if output color is transparent (latched from l619)
l626     Red color output (0..7)
l627     Green color output (0..7)
l628     Blue color output (0..7)
l629     Shadow color flag? (also see w1102)
l630     Highlight color flag (see w1101/w1102 for normal/shadow)

t1       Set when writing reg $17 with DMD1=0, clear when CPU bus grant (or reset)
t2       "In DMA copy/fill" flag
t3       BGACK (low logic)
t4       "In DMA transfer" flag
t5       Set when interrupt acknowledge arrives
t7       Hblank interrupt pending
t8       External interrupt pending
t9       Vblank interrupt pending (status port F bit)
t10      Status port SOVR bit
t11      Status port C bit
t12      Set to fire the interrupt in MD mode (be more specific?)
t13      Sets the latch pipeline during access to DATA/CTRL (I think?)
t14      Seems to be set while VDP is waiting for data from VRAM/CRAM/VSRAM to be latched on a read
t15      Which command byte to write next in SMS mode? (t16 gated by w154?)
t16      Which command byte to write next in SMS mode?
t18      Which command word to write next? (0: low, 1: high)
t19      CPU upper byte strobe (set by UDS, clear by w189)
t20      CPU lower byte strobe (set by LDS, clear by w189)
t21      In the middle of a DATA port write
t25      Writing command bits 15:8 (set by w164, clear by w176)
t28      Set when a FIFO entry is flushed during DMA, reset when DMA finishes
t30      hblank? (later delayed by 1 in m4, by 2 in m5)
t32      hsync (equalization pulses, later delayed by 1 in m4, by 2 in m5)
t33      hsync (normal hsync, later delayed by 1 in m4, by 2 in m5)
t37      disable color output (vertical)

cpu_sel        1 = 68000, 0 = Z80

reg_80_b0      Reg 00:0 = external sync
reg_m3         Reg 00:1 = HV counter latch
reg_80_b2      Reg 00:2 = mode 4 enable (that bit that messes with color depth)
reg_80_b3      Reg 00:3
reg_ie1        Reg 00:4 = hblank interrupt enable
reg_lcb        Reg 00:5 = left column blank
reg_80_b6      Reg 00:6 = mode 4 hscroll inhibit
reg_80_b7      Reg 00:7 = mode 4 vscroll inhibit

reg_81_b0      Reg 01:0 = mode 4 MAG bit
reg_81_b1      Reg 01:1 = mode 4 sprite size
reg_m5         Reg 01:2 = mode 5 enable
reg_m2         Reg 01:3 = V28/V30 select
reg_m1         Reg 01:4 = DMA enable
reg_ie0        Reg 01:5 = vblank interrupt enable
reg_disp       Reg 01:6 = display enable
reg_81_b7      Reg 01:7 = VRAM bus mode

reg_lscr       Reg 0B:0 = hscroll mode
reg_hscr       Reg 0B:1 = hscroll mode
reg_vscr       Reg 0B:2 = vscroll mode
reg_ie2        Reg 0B:3 = external interrupt enable
reg_8b_b4      Reg 0B:4 = VRAM address MSB override
reg_8b_b5      Reg 0B:5 = VRAM address MSB select
reg_8b_b6      Reg 0B:6 = DRAM operation
reg_8b_b7      Reg 0B:7 = DRAM address vs. color bus output

reg_rs1        Reg 0C:0 = H32/H40 select
reg_lsm0       Reg 0C:1 = interlaced mode select
reg_lsm1       Reg 0C:2 = interlaced mode select
reg_ste        Reg 0C:3 = shadow/highlight enable
reg_8c_b4      Reg 0C:4
reg_8c_b5      Reg 0C:5
reg_8c_b6      Reg 0C:6
reg_rs0        Reg 0C:7 = DCLK/EDCLK select

reg_86_b2      Reg 06:2 = sprite bank in mode 4
reg_86_b5      Reg 06:5 = sprite bank in mode 5
reg_8e_b0      Reg 0E:0 = plane A bank in mode 5
reg_8e_b4      Reg 0E:4 = plane B bank in mode 5

reg_sa         Reg 02:6/3 = plane A table address (mode 5)
reg_nt         Reg 02:2/1 = plane A table address (mode 4)
reg_sb         Reg 04:3/0 = plane B table address
reg_wd         Reg 03:6/1 = window table address
reg_hs         Reg 0D:6/0 = hscroll table address

reg_hsz        Reg 10:1/0 = plane A/B width
reg_vsz        Reg 10:5/4 = plane A/B height
reg_88         Reg 08 = mode 4 hscroll
l179           Reg 09 = mode 4 vscroll

reg_col_index  Reg 07:3/0 = background color
reg_col_pal    Reg 07:5/4 = background palette
reg_col_b6     Reg 07:6
reg_col_b7     Reg 07:7

reg_inc        Reg 0F = autoincrement
reg_lg         Reg 13/14 = DMA length
reg_sa_low     Reg 16/15 = DMA source address low
reg_sa_high    Reg 17:5/0 = DMA source address high
reg_dmd        Reg 17:7/6 = DMA type

reg_code       Command CD5:0 input
reg_addr       Command address input
reg_data_l2    Current command address
reg_data_sum   Autoincremented address
reg_data_mux   Current or incremented address (see w185)

reg_test_18    Selected test port
reg_test0      Test port #0


* Register write enables at w210..w233 (not in order, see below)

      $00 w216    $08 w231    $10 w224
      $01 w217    $09 w230    $11 w223
      $02 w218    $0A w229    $12 w222
      $03 w219    $0B w213    $13 w211
      $04 w220    $0C w215    $14 w212
      $05 w226    $0D w233    $15 w228
      $06 w225    $0E w232    $16 w214
      $07 w221    $0F w210    $17 w227

* w942..w949 determine whether a sprite pixel can be rewritten or not. They're
  muxes: looks like w950 would have picked between underdraw or overdraw (i.e.
  front to back or back to front), but in practice it's hardwired to always do
  underdraw.

* YS is overriden by test reg $0 bit 5: when set, it outputs VRAM address MSB.

* CRAM in mode 4 stores the colors as xxxbbggrr internally (removing the gaps).
  The "xxx" is stored from data bus bits 11:9 as usual (what would be "bbb" in
  mode 5), but this would be out of reach from the Z80 (would it be open bus or
  what else?). 68000 should be able to write to those, however.


Line 2762      CPU address decoding
Line 2979      Register write enables
Line 3287      HV counter latch?
Line 3013      FIFO storage? (address)
Line 3306      FIFO storage? (data)
Line 3345      Command CD4:0 input latch (reg_code[4:0], where's CD5?)
Line 3348      Command address input latch (reg_addr)
Line 3355      Command address latch (reg_data_l2)
Line 3361      Register $00 latch
Line 3371      Register $0C latch
Line 3380      Register $01 latch
Line 3390      Register $0B latch
Line 3399      Register $0F latch
Line 3401      Register $17 latch
Line 3405      Register $13 latch
Line 3408      Register $14 latch
Line 3411      Register $15 latch
Line 3414      Register $16 latch
Line 3831      PLA V
Line 3880      PLA H #1
Line 3944      PLA H #2
Line 4598      CRAM address set
Line 5972      Sprite table cache
Line 6020      Sprite drawing?
Line 6067      Line buffer
Line 6073      Line buffer data input
Line 6120      Line buffer write
Line 6139      Line buffer read
Line 6268      VRAM physical address
Line 6322      Layer muxer
Line 6453      Register $07 latch
Line 7106      Data bus pin output
Line 7122      Data bus pin direction
