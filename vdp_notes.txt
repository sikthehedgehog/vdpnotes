w1       68000 read (any size)
w2       Address >= $E00000 and no CPU interrupt acknowledge (w35)?
w4       Release 68000 bus (used by DMA)
w5       Request 68000 bus (used by DMA)
w6       Clear during the 2nd and 4th cycle of a refresh slot
w7       Set during the 2nd and 4th cycle of a refresh slot if FIFO is not full
w8       Set while in DMA transfer (after it has been going for at least 1 dot)
w9       Set when any interrupt pending
w11      IRQ number to assert (bit 1)
w12      IRQ number to assert (bit 2)
w13      not refresh slot and DMA transfer from RAM
w17      l2 & l8 (unused, not connected anywhere)
w35      No CPU interrupt acknowledge?
w37      No CPU address strobe (68000)
w43      Set when counter dff29..23_l2 == 0x7F (fed to dff14_l2)
w44      Set when counter dff29..23_l2 >= 0x70 (fed to dff13_l2, dff15_l2)
w45      CPU interrupt acknowledge (68000)
w46      CPU interrupt acknowledge
w47      CPU interrupt acknowledge (Z80), also expose IRQ number on the bus
w48      CPU interrupt acknowledge in mode 5
w49      Clear pending interrupts (from l9, from w48)
w50      Reset OR read enable CTRL
w53      Clear F flag in mode 4 on status read
w54      Clear external interrupt pending
w56      Clear vblank interrupt pending (F flag)
w57      Set to trigger hblank interrupt
w58      Set to trigger external interrupt
w59      Set external interrupt pending
w60      Set to trigger vblank interrupt
w61      Allow DMA flag
w62      Start DMA transfer
w63      Start DMA copy or fill
w64      Assert BGACK (high logic)
w65      Swap status port bits 1:0 with 9:8 (req: SMS mode, mode 5, mirror status port, wtf?)
w66      Set sprite overflow flag
w67      Set to count down the counter for next hblank interrupt
w68      (not sure, but also part of the logic to load the hblank int line counter)
w69      Set to load line counter for next hblank interrupt
w70      68k within VDP address range (address must be 110xx000 xxxxxxxx 000xxxxx)
w71      Output extra V and H counter bits over CPU data bus (test feature, SMS mode only)
w72      Status port PAL bit (or FIFO full if w65 set)
w73      Status port DMA bit (or FIFO empty if w65 set)
w74      Selected test port $F
w75      Selected test port $8
w76      Selected test port $7
w77      Selected test port $6
w78      Selected test port $5
w79      Selected test port $4
w80      Selected test port $3
w81      Selected test port $2
w82      Selected test port $1
w83      Selected test port $0
w84      Write enable for test port $0
w85      Write enable for test port $1
w86      Write enable for test port $2
w87      Read enable for test port $2
w88      Write enable for test port $3
w89      Read enable for test port $3
w90      Write enable for test port $4
w91      Read enable for test port $4
w92      Write enable for test port $5
w93      Read enable for test port $5
w94      Write enable for test port $6
w95      Read enable for test port $6
w96      Write enable for test port $7
w97      Read enable for test port $7
w98      Write enable for test port $8
w99      Read enable for test port $8
w100     Write enable for test port $F
w101     DRAM row and column mux select (passed to w103)
w103     RA output, color bus vs. DRAM address mux (involves reg $0B bit 7 and w101)
w104     DRAM ASEL signal (involves reg $0B bit 7)
w105     ??? (controlled by debug reg $00 bit 0, involves color)
w106     Interlaced mode 2 enable (high resolution)
w107     V28 enable
w108     V30 enable
w109     128KB mode enable
w110     Write enable for PSG (SMS mode)
w111     Write enable for PSG
w112     Read enable for DATA/CTRL (SMS mode)
w113     Read enable for DATA/CTRL
w114     Read enable for CTRL
w117     /DTACK (but high logic, unlike the pin)
w120     Set F flag, also sets whatever is t12 (see w121)
w121     ??? (resets t12)
w122     Fire the interrupt (be more specific? high or low logic?) (68k=t12, Z80=w9)
w123     V counter latch bottom bit
w124     68000 CPU access detected
w125     /DTACK logic from w146, limited to 68000 (goes to w117)
w128     Write enable for debug address port (MD mode)
w129     Write enable for debug data port (MD mode)
w130     Select between subports (for paired ports)
w131     Write enable for DATA/CTRL (MD mode)
w132     Read enable for DATA/CTRL (MD mode)
w133     Write enable for PSG (MD mode)
w134     Read enable for latched V counter // Read enable for HV counter (MD mode)
w135     Read enable for debug register (MD mode)
w136     End of DMA transfer (or reset)
w137     Assert /DTACK (seems logic for halting on DMA transfers and for halting on reads)
w138     Seems to be set when data is available to read
w139     Write enable for DATA/CTRL
w140     Write enable for DATA/CTRL (SMS mode)
w141     Read enable for HV counter (SMS mode)
w142     Read enable for latched H counter // Read enable for HV counter
w143     Read enable for DATA? (used for t14 and t24)
w144     (clears t18, seems related to CPU writes)
w145     (sets t18, seems related to CPU writes)
w146     Part of /DTACK logic (all this goes to w117 via w125)
w147     (68000?) CPU strobe (either upper or lower)
w149     DATA write detect used for FIFO writes (aligned to w154)
w150     DATA write detect used for FIFO writes (aligned to w153)
w151     (low logic) VRAM data output strobe
w152     Any port read (DATA/CTRL, HV, or test register)
w153     DATA/CTRL access detect, set 2.0 DCLK later, reset 3.0 DCLK later / DATA/CTRL access strobe for w150
w154     DATA/CTRL access detect, set 2.0 DCLK later, reset 2.5 DCLK later / DATA/CTRL access strobe for w149
w155     DATA/CTRL access detect, set 2.5 DCLK later, reset 3.0 DCLK later / Select high word for next command write?
w156     FIFO empty or end of DMA
w158     Set to allow detection of 68000 access
w159     Used to reset t13 shortly after it started the access sequence (resets t13 when l24 goes high)
w160     Read enable for DATA
w163     Access to DATA/CTRL (read or write)
w164     Write command bits 15:8
w165     Write command bits 7:0
w166     Write command bits 7:0 (SMS mode), select upper byte next
w167     Write command bits 15:8? (SMS mode) Write enable for CTRL?
w168     Write command bits 23:16
w169     Write enable for DATA
w170     Select low byte for next command write (SMS mode) (same as w174 but before RESET is added)
w171     Select low word for next command write?
w174     Select low byte for next command write (SMS mode) (same as w170 but with RESET thrown in)
w175     Select low word for next command write? (same as w171 but with RESET thrown in)
w176     Select high word for next command write? (same as w155 but with RESET thrown in)
w177     [w189 is involed somehow] Not CRAM nor VSRAM selected for reading (from w201 and w202)
w178     CRAM read enable (goes to l623_1 -> l623_2 -> l623_3)
w182     CD5 flag (actually combinatorial and not a latch)
w183     End of DATA/CTRL access? detect, set 4.0 DCLK later, reset 4.5 DCLK later
w184     DATA/CTRL access detect, set 2.5 DCLK later, reset 3.5 DCLK later (used by w193 when detecting register writes)
w185     Selects between current (1) or autoincremented (0) address
w186     (part of the logic for w187 and w188, latched through l27)
w187     (not sure but seems to be when writes trigger inside DMA copy?)
w188     (not sure but seems to be when writes trigger outside DMA copy?)
w191     Put current command address on VRAM bus (DMA destination address, I guess)
w192     reg_code[1:0] != 2'h2 (not a register write)
w193     Detected a register write? (pipelines to l31..l34,w205)
w195     Put current DMA source address on VRAM bus
w197     Resets t27 (used during DMA end?)
w198     Sets t27 (used during DMA start?)
w199     DMA copy in progress and CD4 set
w201     [not sure how w189 is involved but] Selected VSRAM for reading (goes to l206)
w202     [not sure how w189 is involved but] Selected CRAM for reading
w204     Reset command bits 23:16 (triggered by reset or mode 4)
w205     Register write enable (from l31)
w206     Register 00*** write enable
w207     Register 01*** write enable
w208     Register 10*** write enable (mode 5 required)
w209     Register 01*** write enable (mode 5 required)
w210     Register 01111 ($0F) write enable
w211     Register 10011 ($13) write enable
w212     Register 10100 ($14) write enable
w213     Register 01011 ($0B) write enable
w214     Register 10110 ($16) write enable
w215     Register 01100 ($0C) write enable
w216     Register 00000 ($00) write enable
w217     Register 00001 ($01) write enable
w218     Register 00010 ($02) write enable
w219     Register 00011 ($03) write enable
w220     Register 00100 ($04) write enable
w221     Register 00111 ($07) write enable
w222     Register 10010 ($12) write enable
w223     Register 10001 ($11) write enable
w224     Register 10000 ($10) write enable
w225     Register 00110 ($06) write enable
w226     Register 00101 ($05) write enable
w227     Register 10111 ($17) write enable
w228     Register 10101 ($15) write enable
w229     Register 01010 ($0A) write enable
w230     Register 01001 ($09) write enable
w231     Register 01000 ($08) write enable
w232     Register 01110 ($0E) write enable
w233     Register 01101 ($0D) write enable
w234     Increment DMA source and decrement length by 256 (if reg_test0[1] == 1)
w235     Increment DMA source and decrement length by 1 (if reg_test0[1] == 0)
w244     End of DMA transfer, 1 iteration early?
w245     DMA in progress & reg_dmd == 2'h3 (DMA copy)
w246     DMA in progress & reg_dmd == 2'h1 (DMA transfer from RAM)
w247     DMA in progress & reg_dmd == 2'h0 (DMA transfer from ROM)
w248     DMA in progress & reg_dmd == 2'h2 (DMA fill)
w249     Set if data write coming from DMA? (guessing from context, merged with VDP data write in w304)
w250     Increment DMA source address
w251     Decrement DMA length (second byte)
w252     Status port FULL bit (0 = FIFO has room, 1 = FIFO is full)
w254     Is FIFO still empty?
w255     Increment DMA source address (second byte)
w256     Send entry address from FIFO to VRAM bus (see below)
w257     w256 when FIFO index == 1, sends entry's address (l36) to VRAM address bus
w258     w256 when FIFO index == 0, sends entry's address (l37) to VRAM address bus
w259     w256 when FIFO index == 3, sends entry's address (l38) to VRAM address bus
w260     w256 when FIFO index == 2, sends entry's address (l39) to VRAM address bus
w262     [UNUSED!!] DMA fill and w300
w263     Set when DMA fill and FIFO empty
w264     Increment FIFO write index; data write (through DATA port access or DMA transfer)
w267     DMA in progress & reg_dmd[1] == 0 (DMA transfer from ROM or RAM)
w268     Set to output data from FIFO to data bus
w269     Time to flush FIFO entry (free access slot and FIFO not empty) (to l49)
w270     Clears t28 when DMA is over
w271     Sets t28 when a FIFO flush happens while in DMA
w272     [?] Set when DMA fill can proceed? (after the initial write is done) (goes to l50)
w273     68000 and 64KB VRAM and CD2:1 == 0 (VRAM) // 68000 and CD == 8-bit VRAM write
w274     68000 and 64KB VRAM
w275     Set to output l35 on the VRAM address bus with LSB inverted
w276     Upper byte FIFO write strobe (68000 bus), also held high by DMA access
w277     Upper byte FIFO write (see l55..l58)
w278     Lower byte FIFO write strobe (68000 bus), also held high by DMA access
w279     Lower byte FIFO write (see l59..l62)
w280     Which FIFO byte is being written in mode 5 (used with Z80 bus)
w281     [?] DMA copy write to odd address?
w282     [?] DMA copy write to even address?
w283     VRAM write to upper byte? (used to detect sprite cache writes, see w693)
w284     VRAM write to lower byte? (used to detect sprite cache writes, see w694)
w285     Lower byte flag OR 64KB VRAM mode
w286     VRAM write to lower byte (goes to VRAM interface block, see w991)
w287     Upper byte flag AND 128KB VRAM mode
w288     VRAM write to upper byte (goes to VRAM interface block, see w999)
w289     Live/FIFO CD flags: VRAM write (CD3:0 == 0001)
w290     FIFO write enable for data
w291     FIFO write enable for 3rd slot data
w292     FIFO write enable for 4th slot data
w293     FIFO write enable for 1st slot data
w294     FIFO write enable for 2nd slot data
w295     Both FIFO indices match, used to detect when FIFO becomes full or empty
w296     Set when incrementing FIFO read index by half entry
w297     Set when incrementing FIFO read index by one entry
w299     Latch current VRAM address into l35
w300     68000 and 64KB VRAM and CD2:1 == 0 (VRAM) and about to flush second byte of a FIFO entry
w301     CD0 flag & doing an access?
w302     CRAM write enable, upper byte (goes to l601 and w1021)
w303     CRAM write enable, lower byte (goes to l602 and w1021)
w304     Updates l94 and l95 (the bytes that are used for FIFO writes)
w305     FIFO read index increment size (1: by half entry, 0: by one entry)
w306     Set when FIFO read index == 3
w307     Set when FIFO read index == 2
w308     Set when FIFO read index == 1
w309     Set when FIFO read index == 0
w310     FIFO CD1 flag for current entry
w311     FIFO upper byte flag for current entry
w312     FIFO CD2 flag for current entry
w313     FIFO lower byte flag for current entry
w314     FIFO CD3 flag for current entry
w315     FIFO CD0 flag for current entry
w316     Live flag or FIFO CD1 flag for current entry
w317     Live flag or FIFO upper byte flag for current entry
w318     Live flag or FIFO CD2 flag for current entry
w319     Live flag or FIFO lower byte flag for current entry
w320     Live flag or FIFO CD3 flag for current entry
w321     Live flag or FIFO CD0 flag for current entry
w322     CD0 from FIFO in mode 5 or CD0 always high in mode 4
w323     VSRAM write, upper byte (goes to l207)
w324     VSRAM write, lower byte (goes to l208)
w325     CD2:1 == 00 (VRAM select) (either live or FIFO, depending on l50)
w326     Sends FIFO entry #0 to VRAM data bus
w328     Sends FIFO entry #2 to VRAM data bus
w327     Sends FIFO entry #1 to VRAM data bus
w329     Sends FIFO entry #3 to VRAM data bus
w330     NOT (68000, 8-bit VRAM write, byte-sized FIFO entry)
w331     Used to select what will go in the low byte of the VRAM write
w332     Upper XOR lower valid byte in FIFO (*not* both)
w333     Set to swap low byte of HV counter port (used to accomodate Z80 bus)
w334     Enable H counter latch freerunning in mode 5
w335     External interrupt pulse (one dot long) (goes to l81, used for HV counter latch)
w336     V counter latch enable
w337     H counter latch enable
w338     For w346: set if it's a VRAM read (CD3:2 == 00)
w339     ??? (set when w346 set and VRAM address is even)
w340     ??? (set when w346 set and VRAM address is odd)
w341     Gate latching for upper byte of VRAM read (goes to l88)
w342     Gate latching for lower byte of VRAM read (goes to l89)
w343     Update upper byte of VRAM read
w344     Update lower byte of VRAM read
w345     For w348: selects which VRAM byte to show to the Z80
w346     For w349: selects which VRAM byte is source for upper byte for 68k
w347     Select what to put in low byte when reading HV counter
w348     Lower byte of a DATA read (latched in l92)
w349     Upper byte of a DATA read (latched in l93)
w350     Selects source of upper byte for command write (depending on CPU type)
w351     When outputting to VRAM data bus, selects byte for FIFO entry #0 data (lower byte)
w352     When outputting to VRAM data bus, selects byte for FIFO entry #1 data (lower byte)
w353     When outputting to VRAM data bus, selects byte for FIFO entry #2 data (lower byte)
w354     When outputting to VRAM data bus, selects byte for FIFO entry #3 data (lower byte)
w355     Logical Y coordinate
w356     reg_test1[6:4] == 3'h1 OR 3'h0 and time for plane A tilemap fetch
w357     reg_test1[6:4] == 3'h1 (used by w356)
w358     (part of the expression in w359)
w359     Free VRAM slot (CPU access allowed) (latched in l109)
w360     Set if hpos = 258+1 (H32) or 322+1 (H40), 1 dot later than when F flag is cleared (from l117, undoes invert)
w361     Do H counter wraparound
w362     Increment H counter by 1px (when test register #1 bit 3 is not set)
w363     Increment H counter by 1px (including also test register)
w364     Value to load when H counter wraps around
w365     (used to compute w364, see above)
w366     (used to compute w364, see above)
w367     (used to compute w364, see above)
w368     (used to compute w364, see above)
w369     (used to compute w364, see above)
w370     From external sync: H counter wraparound
w371     reg_test1[6:4] == 3'h2 (used by w372)
w372     reg_test1[6:4] == 3'h2 OR 3'h0 and time for plane B tilemap fetch
w373     actual vsync to output (selects between mode 4 or mode 5 vsyncs)
w374     selects between vsync or hclk2 for the /VSYNC pin
w375     external csync OR external hsync (latter when enabled)
w378     VSRAM timing to use? (reg_vscr ? l124 : ~l117)
w379     w378, but only when reg_test1[6:4] == 3'h0
w380     reg_test1[6:4] == 3'h0
w381     reg_test1[6:4] == 3'h5
w382     reg_test1[6:4] == 3'h3 (forces w385 high)
w383     reg_test1[6:4] == 3'h4 (forces w394 high)
w385     Timing signal: fetch plane A or B tile data (1st half) (from l125)
w386     (part of the expression in w359)
w387     Intended /CSYNC output for the current mode, before it's filtered by external sync (goes to w397)
w388     Set while in viewport area and active scan (also in l470 two dots later)
w389     Set while in viewport area (in H and V range and display enabled)
w390     Pre-vsync or post-vsync in mode 5 (NOT during vsync itself!)
w392     Combines l137 (start of right border) with reset to force border on VDP reset, goes to t29
w393     Passes the PLA signal from w507/l133 only if test reg 1[6:4] == 3'b000
w394     Timing signal: fetch plane A or B tile data (2nd half) (from l126)
w395     (part of the expression in w359)
w396     Hsync (for current mode)
w397     Disables /CSYNC output if external sync is on (goes to l128, the /CSYNC latch)
w398     Select between full hsync pulses and half hsync pulses
w399     Timing for half hsync pulses? (~w398 AND mid-line hsync pulses)
w400     Pre-vsync or post-vsync in mode 5 and mid-line hsync pulses?
w401     Start of hblank OR reset
w402     Passes the PLA signal from w508/l140 only if test reg 1[6:4] == 3'b000
w403     ??? (just merges w410 with its delayed signal)
w404     Hsync output gated by hsync dir bit (comes from w396, goes to l136)
w405     Timing for full hsync pulses? (w398 AND normal hsync pulses)
w406     (same as w405)
w407     Sets t31, hsync for external sync?
w408     Resets t31, hsync for external sync? (w409 OR reset, same logic as w414)
w409     Start of hsync (standard or mid-line)
w410     H counter wraparound & SPA/B as input & external sync (???)
w411     External hsync, when enabled by reg $0C (gated from l149)
w412     (something hsync? w405 OR w399)
w413     (something hsync? w406 OR w400 OR w391)
w414     H Timing signal: start of short hsync pulse (same logic as w408)
w416     SPA/B input and external sync (related to sprite timing?)
w419     Lets you force hscroll table fetch when reg_test1[6:4] == 3'h5
w420     Intended /CSYNC output, for use in mode 4
w421     w427=0 pulse every hsync, w427=1 toggle every hsync?
w422     Status port HB bit (0 = not in hblank, 1 = in hblank)
w423     H Timing signal: start of hsync
w424     (takes l159 and passes it only if test reg 1[6:4] == 0, passes it to w614)
w425     w416 & ~reg_81_b0 => ~reg_8c_b4 & reg_80_b0 & ~reg_81_b0 (related to sprites?)
w427     Reg $00 bit 3 set in mode 5 (selects output of w421)
w428     Value to use V counter when it wraps around
w429     (used to compute w428, see above)
w430     (used to compute w428, see above)
w431     (used to compute w428, see above)
w432     (used to compute w428, see above)
w433     (used to compute w428, see above)
w434     (used to compute w428, see above)
w435     (used to compute w428, see above)
w436     Do V counter increment
w437     Do V counter wraparound/reload (any reason)
w438     Do V counter wraparound from internal sync (i.e. H and V are at the right place)
w439     Status port VB bit (0 = active scan, 1 = passive scan)
w440     (resets t34, w442 + VDP reset)
w442     (resets t34, from w474 via l163)
w441     t34 (the 3 lines post-vsync) but only in mode 5
w443     t35 (the 3 lines in vsync) but only in mode 5
w444     Set when vsync should end
w445     Set when vsync should begin (same as w447, but also including reset)
w446     Status port ODD bit (0 = even field, 1 = odd field) [1-bit "counter", not actually a wire!!]
w447     Set when vsync should begin
w448     (duplicated circuit, same as w445)
w449     Used to determine where mid-scanline vsync begin
w450     t36 (the 3 lines pre-vsync) but only in mode 5
w451     Clear even/odd flag (force even flag)
w452     Set to start the pre-vsync period (sets t36)
w453     Set to disable color output (sets t37)
w454     Used by w451 and w456, external sync enabled and H counter = 0 on the line vblank begins
w455     Toggle even/odd flag (external sync disabled and H counter = 0 on the line vblank begins)
w456     Set even/odd flag (force odd flag, goes to l168 instead of directly to w446)
w457     Start of vblank (opposite of w469, latched from l170), also latches interlaced mode
w458     Reset OR start of vblank
w459     Used by w454 and w455, H counter = 0 on the line vblank begins (delayed by 1 dot)
w460     External sync and w464 rising edge (1 dot latency)
w462     Combines reset and l167 (start of top border / end of vblank)
w466     Opposite of w439 (1 = active scan, 0 = passive scan), used for PLA conditions
w467     V Timing signal: V counter wraparound point (goes to l174)
w468     V Timing signal: (low logic) end of vblank / start of vertical visible area
w469     V Timing signal: (low logic) start of vblank / end of vertical visible area
w470     V Timing signal: end of bottom border / start of bottom TV blank (always 3 lines before w472)
w471     V Timing signal: start of top border / end of top TV blank
w472     V Timing signal: start of vsync (always 3 lines before w473)
w473     V Timing signal: end of vsync / start of top TV vblank
w474     V Timing signal: ??? (always 3 lines after w473, end of the extra sync pulses maybe?)
w475     V Timing signal: (low logic) line 511
w476     H Timing signal: refresh slot (goes to l108)
w477     H Timing signal: fetch plane A tilemap data
w478     H Timing signal: fetch plane B tilemap data
w479     H Timing signal: set up fetch address plane A or B tile data (1st half)
w480     H Timing signal: set up fetch address plane A or B tile data (2nd half)
w481     H Timing signal: fetch sprite X and tile ID
w482     H Timing signal: fetch sprite tile (fed into l141)
w483     H Timing signal: odd pixels (for what is this used? seems related to FIFO flushes? used by w384 and w386)
w484     H Timing singal: m4 sprite tile fetch (1st half)
w485     H Timing signal: m4 sprite X / tile ID fetches? (active scan only, passive scan is weird) (to l155)
w486     H Timing signal: m4 sprite Y fetches?
w487     H Timing signal: m4 fetch sprite Y data???, m5 scan sprite Y data? (fed into l147)
w488     H Timing signal: fetch hscroll table (fed into l148)
w490     H Timing signal: H counter wraparound point
w491     H Timing signal: ??? (used by H counter external sync logic)
w492     H Timing signal: ??? (used by V counter external sync logic)
w493     H Timing signal: start of horizontal display (end of left border)
w494     H Timing signal: end of horizontal display (start of right border)
w495     H Timing signal: start of hblank (hblank flag set)
w496     H Timing signal: end of hblank (hblank flag clear)
w497     H Timing signal: half a scanline before end of horizontal display (170 dots for H32, 210 dots for H40)
w498     H Timing signal: start of mid-line hsync pulse (4px/11px early?)
w499     H Timing signal: end of short hsync pulse (4px/11px early?)
w500     H Timing signal: start of standard hsync (early 4px in m4, 11px in m5), start of back porch (2px early)
w501     H Timing signal: end of long hsync (early 4px in m4, 11px in m5)
w502     H Timing signal: increment or warparound V counter (low logic)
w503     H Timing signal: H position of middle of the scanline (1 dot wide, used for interlaced mode, goes to l111)
w504     H Timing signal: H counter = 0
w505     H Timing signal: VSRAM read in full vscroll (low logic), when F flag is cleared in SMS mode
w506     H Timing signal: VSRAM read in column vscroll (H counter is multiple of 8px (0, 8, 16, 24...504))
w507     H Timing signal: latch tile data for plane A (H counter multiple of 8px +7 (mode 4), multiple of 16px +7 (mode 5))
w508     H Timing signal: latch tile data for plane B (H counter multiple of 16px +15)
w509     H Timing signal: ??? (same as w510 but for mode 4?) (to l146)
w510     H Timing signal: 3px after sprite X & tile ID fetch in mode 5 (to l145)
w511     H Timing signal: H counter = 507 (-5), used for plane B? (to l154)
w512     H Timing signal: something to do with hscroll (H counter multiple of 16px +3)
w513     Set when latching a value from VSRAM into l185
w515     VScroll value to work with (VSRAM output in m5, reg $09 in m4) (plane A?) (stored in l184)
w516     Set when latching a value from VSRAM into l180
w518     VScroll value to work with (from l184), with vscroll inhibit applied if needed (from l186)
w519     Clear when vscroll inhibit should kick in, set otherwise (stored in l186)
w520     Selects plane A (0) or B (1) for vscroll source
w521     Y scroll offset (to add to screen Y coordinate, see w355 and w522)
w522     Y coordinate to access in the tilemap (before interlaced mode adjustment)
w523     Set if plane A/B size is 32 tiles (reg_hsz == 2'h0)
w524     Set if plane A/B size is 64 tiles (reg_hsz == 2'h1)
w525     Set if plane A/B size is 128 tiles (reg_hsz == 2'h3)
w526     Y coordinate to access in the tilemap (before wraparound, accounting for IM2)
w527     Offset to access in the tilemap (X and Y merged)
w528     Actual Y coordinate to access in the tilemap (see w527)
w529     Same as w530 (see below) in mode 4, forced to 0 in mode 5 (used for calculating w528)
w530     Do Y scroll wraparound? (for mode 4, goes to w529)
w531     Set to output tilemap fetch address bits 16:14 on VRAM address bus
w532     Plane address bits 16:13 (put on VRAM bus) / Either m5 plane A or B address bits 16:13 (depending on l200)
w533     Plane address bits 12:11 (put on VRAM bus) / Either (m4) plane A or (m5) address bits 12:11
w534     Set when H counter is not within 384..511 (used for w539)
w535     Hscroll line to read (after applying hscroll mode bits)
w536     X offset within window tilemap (accounts for H32 or H40)
w537     Which hscroll line to fetch? (drops LSB of logical Y coordinate, should match l105[7:0])
w538     Set when within the window X region
w539     Set when within the window X region and X < 384
w540     Set when within the window Y region
w541     Selects plane A (0) or window (1) for output (goes to l217)
w542     Latch window X register (into l187 and l188)
w543     Latch window Y register (w/o test register, into w544)
w544     Latch window Y register (into l189 and l190)
w545     Which side of window Y split? (1: above, 0: below)
w546     Which side of window X split? (0: left, 1: right)
w547     V counter increment OR test reg1 b7 (same as w542), forces latching mode 4 hscroll
w548     Timing signal: fetch plane A or B tile data (either half) (from w385 and w394)
w550     Timing signal: fetch plane A or B tile data (2nd half in mode 4)
w551     Timing signal: fetch plane A or B tile data (1st half in either mode, 2nd half in mode 4)
w552     Set if hscroll inhibit should kick in (in mode 4)
w553     Clear to latch hscroll for plane A in mode 4
w554     Hscroll value to use when fetching, INVERTED (i.e. NOT'd)
w555     Actual X coordinate to access in the tilemap (upper bits used in w527, lower bits in VRAM address bus)
w556     Set when we want to set the address for a plane B tile name fetch (goes to l200)
w557     Set when we want to set the address for a plane A tile name fetch (goes to l201)
w558     Set to output tilemap fetch address bits 13:0 on VRAM address bus
w559     VRAM address output enable: window plane tile name fetch (to l202)
w560     Set if time to fetch plane A or B tilemap, or HL pulse when reg_test1[8]
w561     (used for the w555 sum) Set if in left/right border (H32: H counter >= 256; H40: >= 320)
w562     (used for the w555 sum) Set if in viewport horizontally and in mode 4
w563     (used for the w555 sum) Set if in viewport horizontally in mode 4 and odd tile (H counter = multiple of 16px + 8px)
w564     (used for the w555 sum) Hscroll bit 3 (NOT'd) in mode 4 (from w554), always 1 in mode 5
w565     (used for the w555 sum) In viewport horizontally: current 16px column; in border: 4'b1111
w566     VRAM address output enable: bits 16:14 of plane A/B tile fetch
w567     (used for the w555 sum) If in hborder: tilemap width, else: {hcounter >= 320, hcounter >= 256} (???)
w568     (used for the w555 sum) H counter >= 320
w569     Set on VSRAM bus access
w570     Set to latch from VRAM to plane A hscroll bits 7:0 (see l191)
w571     Set to latch from VRAM to plane A hscroll bits 9:8 (see l194)
w572     Set to latch from VRAM to plane B hscroll bits 7:0 (see l192)
w573     Set to latch from VRAM to plane B hscroll bits 9:8 (see l195)
w574     Set to use hscroll for plane A in mode 5
w575     Set to use hscroll for plane B in mode 5
w576     Bits 4:2 of plane A/B tile address to fetch before vflip (also bit 5 in IM2)
w577     Bits 4:2 of plane A/B tile address to fetch (also bit 5 in IM2)
w578     Bits 13:5 of plane A/B 1st tile address to fetch
w579     Bits 16:14 of plane A/B 1st tile address to fetch
w580     Bits 16:5 of plane A/B 2nd tile address to fetch
w581     Mux: plane A or B tile bank (address MSB, selected by l197)
w582     Timing signal: fetch plane A or B tile data (2nd half in mode 5)
w583     *Actual* plane A/B vflip flag in effect
w584     Plane A hflip flag (read from VRAM), adjusted for mode 4/5
w585     Plane A vflip flag (read from VRAM), adjusted for mode 4/5
w586     Plane A palette flags (read from VRAM), adjusted for mode 4/5
w587     Plane A priority flag (read from VRAM), adjusted for mode 4/5
w588     Delays l227 to next cycle, enables latch for l226
w589     Delays l228 to next cycle, enables latch for l225
w590     Delays l229 to next cycle, enables latch for l224
w591     Delays l230 to next cycle, enables latch for l223
w592     Set to copy plane A tile data being latched live (l246:l243,l226:l223) into a safe location (l258:l255,l235:l232)
w594     Delays l247 to next cycle, enables latch for l246
w595     Delays l248 to next cycle, enables latch for l245
w596     Delays l249 to next cycle, enables latch for l244
w597     Delays l250 to next cycle, enables latch for l243
w599     Used to select source for w602~w605
w600     Aligns signal to start latching 1st tile of plane A to hclk1
w601     ??? (used as part of the expression in w606_t)
w602     Plane A or B hflip flag (w599 = 0: plane A, 1: plane B)
w603     Plane A or B palette bit 0 (w599 = 0: plane A, 1: plane B)
w604     Plane A or B palette bit 1 (w599 = 0: plane A, 1: plane B)
w605     Plane A or B priority (w599 = 0: plane A, 1: plane B)
w606     Which pixel within a tile to show for plane A (w606_t if w602 == 0, ~w606_t if w602 == 1)
w606_sel    Decoded from w606, used as select inputs to w607's multiplexers
w607     Plane A color index to show (to l269)
w607_m4     w607 value for mode 4
w607_m5_1   w607 value for mode 5 (1st tile?)
w607_m5_2   w607 value for mode 5 (2nd tile?)
w608     (part of the expression for w609 to account for mode 4 and 5 differences)
w609     Set when we'll need more plane A pixel data for output (see w610)
w610     Set when we'll need more plane A pixel data for output (see w611 too)
w611     Set to copy cached plane A tile data being (l258:l255,l235:l232) into working copy for output (l264:l261,l240:l237)
w612     Forces high the PLA signal from w507/l133 if test reg 1[9] is set and /HL pin is *high*
w613     Aligns signal to start latching 2nd tile of plane A to hclk1
w614     Set 1 dot after w512 (via l159), after being manipulated by the test registers
w615     Set to latch lower byte of plane A/B 1st tilemap fetch
w616     Set to latch upper byte of plane A/B 1st tilemap fetch
w617     Set to latch lower byte of plane A/B 2nd tilemap fetch
w618     Set to latch upper byte of plane A/B 2nd tilemap fetch
w619     [???] (set to latch 1st byte of something into l278, tile fetch?)
w620     [???] (set to latch 2nd byte of something into l277, tile fetch?)
w621     [???] (set to latch 3rd byte of something into l276, tile fetch?)
w622     [???] (set to latch 4th byte of something into l275, tile fetch?)
w623     NOT column vscroll (i.e. mode 5 full vscroll or mode 4)
w624     Set if H counter is multiple of 16px if full vscroll, or if offset +8 if column vscroll
w625     Vscroll column to read from VSRAM
w626     VSRAM addres to access (goes to l212)
w631     Set to copy plane B tile data being latched live (l278:l275,l297:l294) into a safe location (l306:l303,l282:l279)
w634     Plane A or B hflip flag (l311[3] = 0: plane A, 1: plane B)
w635     Plane A or B palette bit 0 (l311[3] = 0: plane A, 1: plane B)
w636     Plane A or B palette bit 1 (l311[3] = 0: plane A, 1: plane B)
w637     Plane A or B priority (l311[3] = 0: plane A, 1: plane B)
w638     Forces high the PLA signal from w508/l140 if test reg 1[10] is set and /HL pin is *high*
w639     Aligns signal to start latching 2nd tile of plane B to hclk1
w640     Aligns signal to start latching 1st tile of plane B to hclk1
w641     Which pixel of plane B tile to show? (0 to 7)
w642     Lets you force a hscroll table fetch when reg_test1[7] == 1 and HL
w643     Set to put hscroll fetch address on VRAM bus
w644     Set when we'll need more plane B pixel data for output (see w645 too)
w645     Set to copy cached plane B tile data being (l282:l279,l306:l303) into working copy for output (l290:l287,l310:l307)
w646     Set if plane A is opaque
w647     Plane B color index to show (to l318)
w648     Set if plane B is opaque
w652     Set to latch sprite size and link from l328 into l332 (narrowed down from l333)
w653     Adds a value to logical Y to account for sprite Y origin ($102 if IM2, $081 if non-IM2 m5, $000 if non-IM2 m4)
w654     Set if non-interlaced mode 5 (used to compute w653)
w655     Set if sprite link == 0 (note: it checks l332 which is inverted)
w656     Sprite height bit 1 (adjusted for both mode 5 and 4) (goes to l338)
w657     Sprite height bit 0 (adjusted for both mode 5 and 4) (goes to l339)
w658     No more sprites? (checks for Y == 208 in m4 and for link == 0 in m5)
w660     Set to latch sprite Y position into l343
w661     [???] Set to latch data from VRAM into l342
w662     Adds the Y origin offset to the sprite Y coordinate
w663     Set if sprite height == 1 tile
w664     Set if sprite height == 3 tiles
w665     Check if sprite is within range vertically (for any size)
w666     Sprite Y position (for either mode 4 or 5) (goes to w667 and l340)
w667     Is end of sprite list in mode 4? (checks if w666 == 208)
w669     Check if sprite is within range vertically when it's 2 tiles high
w670     Check if sprite is within range vertically when it's 3 tiles high
w671     Sprite Y position bit 9 (inverted), forced 1'b1 if not interlaced mode 2
w672     Sprite Y position bit 8 (inverted), forced 1'b1 if in mode 4
w673     Sprite Y position bit 3 (if 8x8 tiles) or bit 4 (if 8x16 tiles)
w674     Sprite Y position bit 4 (if 8x8 tiles) or bit 5 (if 8x16 tiles)
w675     Sprite Y position bit 5 (if 8x8 tiles) or 1'b0 (if 8x16 tiles)
w676     ??? (it's set when it checks if there are no more sprites in w658, also used in w727)
w677     Mode 4 AND whatever l350 is
w680     Sprite Y position, inverted (from l346 if m5, directly from VRAM bus if m4) (goes to l343 when w660 set)
w683     Set to load next sprite link (in mode 5) into sprite ID (l351)
w684     Set to output sprite table offset for sprite Y in VRAM address bus in mode 4, also increments sprite ID (l351)
w686     Set when it's time to scan sprite Y data? (l147 from PLA + in viewport area vertically or line 511)
w687     Set to latch 4th byte of cacheable sprite entry (link)
w688     Set to latch 3rd byte of cacheable sprite entry (size)
w689     Set to latch 1st byte of cacheable sprite entry (Y bits 9:8)
w690     Set to latch 2nd byte of cacheable sprite entry (Y bits 7:0)
w693     Is VRAM address within sprite cache range (upper byte) (goes to l363)
w694     Is VRAM address within sprite cache range (lower byte) (goes to l364)
w695     [???] SAT index (for what?)
w696     Mode 5 sprite table index to access (to l398, and eventually into a shift register made by l403..l409)
w697     Sprite to render index (from l371, may be overriden by test register with CPU bus instead)
w698     Set if l367(?) OR sprite render list index reached 20, latched in l368
w701     Resets sprite render list index back to 0 (through l373)
w702     Set to move to the next sprite queued for render
w703     (see w702, seems to be a trace that could be configured like w704)
w704     (void, was supposed to decrement l371)
w705     reg_test_18[6:5] == 2 (low logic) Use latched sprite [other] for w770
w706     reg_test_18[6:5] == 1 (low logic) Use latched sprite pattern l425 for w770
w707     reg_test_18[6:5] == 0 (low logic) Use latched sprite X coordinate for w770
w714     NOT (either l376 is set OR we're in mode 4)
w717     (part of w738 logic, test register use only)
w719     Sprite Y within range and w743 == 1'b1
w720     Sprite Y within range and w743 == 1'b0
w722     Sprite V flip and height >= 2'b01 (height == 16px,24px,32px), used in w730
w723     Sprite V flip and height == 2'b10 (height == 24px), used in w726
w724     Sprite V flip and height >= 2'b10 (height == 24px,32px), used in w730
w725     Sprite Y tile offset (derived from Y in px, adjusted for interlaced mode)
w726     Adds 1 to sprite Y tile offset (see w725) if width is 3 tiles
w728     Bits 2:0 of sprite Y offset to insert into sprite render list
w729     Bits 5:3 of sprite Y offset to insert into sprite render list
w730     Actual sprite Y offset in tiles after vertical flipping (see w730.txt)
w731     Mode 4 sprite 8x1 fetch tile ID
w732     [???] (from w738, throws in more test register stuff)
w733     Mode 4 sprite Y offset bit 0 / sprite 8x1 fetch address bit 2
w734     Mode 4 sprite Y offset bit 1 / sprite 8x1 fetch address bit 3
w735     Mode 4 sprite Y offset bit 2 / sprite 8x1 fetch address bit 4
w736     Mode 4 sprite Y offset bit 3
w737     Mode 4 sprite 8x1 fetch address bit 5 (either w731[0] or w736 depending on sprite size setting)
w738     [???] w717 when reg_test0[14] == 0
w740     Is VRAM address within sprite table range
w741     Is VRAM address within sprite cache range
w742     Timing signal: sprite tile fetch for mode 4 (enables VRAM bus)
w743     Picks last relevant bit of l410 ([19] for H40, [15] for H32, [7] for m4, tied to max sprite count?)
w744     Set to latch VRAM data into l435 (1st sprite word, low byte)
w745     Set to latch VRAM data into l386 (1st sprite word, high byte)
w746     Set to latch VRAM data into l387 (2nd sprite word, high byte)
w747     Set to request to read 1st sprite word (starts chain l394->l392,l394->w744->l436,l392->w745->l386)
w748     Set to request to read 2nd sprite word (starts chain l395->l393,l395->w749->l435,l393->w746->l387)
w749     Set to latch VRAM data into l436 (2nd sprite word, low byte)
w750     Select timing of signal into l396 (w417 as-is for m5, delayed one dot for m4)
w751     Timing signal: sprite tile fetch for mode 4 (w742, before it's locked out of mode 5)
w752     Sprite index to access (from l400, latched to l403..l409)
w753     (swaps l382 with test reg 6 writes before passing it to l410)
w754     Timing signal: sprite table fetch for mode 4? (l411 and l412, enables VRAM bus)
w755     Timing signal: sprite table fetch for mode 4? (l412 only)
w756     Timing signal: sprite table fetch for mode 5? (enables VRAM bus)
w757     Bottom 7 bits of mode 5 sprite table address to access
w758     Input for sprites to render list bit 20 (hflip)
w759     Mux select for input to sprite list to draw (select when test reg 0 bit 12 = 1)
w760     Mux select for input to sprite list to draw (select when test reg 0 bit 12 = 0)
w761     Input for sprites to render list bits 22:21 (palette ID)
w763     Input for sprites to render list bit 23 (priority)
w764     Input for sprites to render list bits 25:24 (width)
w766     Input for sprites to render list bits 27:26 (height)
w768     Input for sprites to render list bits 33:28 (Y offset within sprite?)
w769     Set to latch data from sprite to render (X pos, tile ID, flags, etc.)
w770     Debug: sprite metadata (yoffset[2:0],height[1:0],width[1:0],pri,pal[1:0],hflip), pattern or X
w771     Set after running out of sprite slices to draw? (used by w772)
w772     Set to latch data from sprite to render (see w769, this is before it's gated to only hclk1)
w774     Input for sprites to render list bits 10:0 (tile ID)
w775     Input for sprites to render list bits 19:11 (X pos)
w776     [???] Set if mode 5 and not resetting the sprite slices counter (goes to l426)
w777     UNUSED, latched in l427 which goes nowhere, used nowhere else
w778     Computes the tile ID offset within sprite from the sprite's Y offset
w779     Tile ID offset within sprite (i.e. add to sprite's base tile ID)
w780     What tile ID to read when fetching a sprite's 8x1px (goes to VRAM address)
w782     [???] Set if sprite X is not 0
w788     Mux which picks which byte is used for base sprite X in mode 4 (l435 or l436) (select value is l422)
w789     Set to in/decrement the current sprite X (through w790 or w798)
w790     Go to previous linebuffer address? (decrements w802 by -1)
w791     (used to build an operand for w800) m5 sprite hflip 16px/32px OR m4 w/8px shift
w792     (used to build an operand for w800) m5 sprite hflip 16px/32px
w793     (used to build an operand for w800) m5 sprite hflip 24px/32px
w794     (used to build an operand for w800) m5 sprite hflip 24px/32px OR m4 w/8px shift
w795     (used to build an operand for w800) m5 sprite hflip
w796     (used to build an operand for w800) m4 w/8px shift
w797     (used to build an operand for w800) m5 sprite OR m4 w/8px shift
w798     Go to next linebuffer address? (increments w802 by +1)
w799     Base sprite X coordinate (used to build an operand for w800)
w800     Initial(?) X column for a sprite in the linebuffer (in 8px steps) (-128px offset is applied here!!)
w801     Selects between w800 and w802 (use new linebuffer address or modify current one?)
w802     Linebuffer address to write to (derived from w800 and regularly incremented or decremented by 1)
w803     l499 on DCLK posedge
w804     Set to load a new width into l457 (width counter)
w805     Same as w804 but limited to hclk1, used to reload l473 (which then is loaded into l472)
w806     Actual sprite width NOT'd, bit 0 (from l442 in mode 5, forced to 8px in mode 4), loaded into l457
w807     Actual sprite width NOT'd, bit 1 (from l442 in mode 5, forced to 8px in mode 4), loaded into l457
w808     Set when l457 (width counter) becomes 11, used by w804 & w805 to detect end of sprite
w809     Linebuffer address when showing it on screen; in M4 = H counter + $1F4+1 ($1F5), in M5 = H counter + $1ED+1 ($1EE)
w810     Set if w802 is within viewport range (if RS1=0: w802 < 32, if RS1=1: w802 < 40)
w811     Sprite priority (once gated by w803, from l451) and viewport area + display enabled (forced to 0 otherwise)
w812     Sprite palette (once gated by w803, from l453) and viewport area + display enabled (forced to 0 otherwise)
w813     Selects whether we're drawing to the left or right of a 8px line buffer boundary (goes to l461)
w814     Merges ~l454 and l460 to generate write enable pulses for sprites
w815     (from l462) Signals when the linebuffer write enables happen (+ test reg 0 bit 13)
w816     (used to stretch w814 for one DCLK cycle longer)
w817     Line buffer write enable (global)
w818     w819 (via l465) OR test reg 0 bit 13 set (something to do with linebuffer write enable?)
w819     (something to do with linebuffer write enable?) hclk2 only if display enabled (low logic)
w820     Set if w821 == 1 OR if H counter[2:0] == 3'h2 in m4 or 3'h1 in m5 (then latched in l466)
w821     NOT set while in viewport area and active scan (timing adjusted for mode 4 or 5)
w822     When set (from w821), use l474 (from w802) as line buffer address
w823     When set, use l475 (from w809) as line buffer address
w824     When set, use reg_test_18 as line buffer address
w825     Line buffer address
w827     Set during sprite drawing when X[2:0] is +5px (within an 8px boundary)
w828     Set when X is right to store pixel #4 when rotating sprite pixels (see w860..w866 for #0..#7)
w829     Timing: set to latch 2nd byte of a sprite's 8x1 px
w830     Timing: set to latch 1st byte of a sprite's 8x1 px
w831     (used to set up the latches that do timing of w830 and w829)
w832     (used to set up the latches that do timing of w833 and w834)
w833     Timing: set to latch 3rd byte of a sprite's 8x1 px
w834     Timing: set to latch 4th byte of a sprite's 8x1 px
w835     Timing: set to copy latched sprite 8x1 bytes into l491-l494 (the work copy)
w836     When 0, starts the chain to pick pixels for w843 (goes to l495 and w846)
w837     Set=0 to pick pixels #6 and #7 for w843_1 (for mode 5, with hflip support)
w838     Set=0 to pick pixels #4 and #5 for w843_1 (for mode 5, with hflip support)
w839     Set=0 to pick pixels #2 and #3 for w843_1 (for mode 5, with hflip support)
w840     Set=0 to pick pixels #0 and #1 for w843_1 (for mode 5, with hflip support)
w841     NOT end of viewport while in mode 5, used for sprite rendering
w842     NOT end of viewport while in mode 4, used for sprite rendering
w843     Seems to pick ONE pair of pixels and rearrange sprite pixel bits (mode 4 vs. mode 5) during rendering
w843_1   Sprite pixels in mode 5 format (chunky)
w843_2   Sprite pixels in mode 4 format (planar)
w844     When w847 is set it swaps the two pixels in w843, otherwise it passes w843 as-is
w845     If test reg 0 bit 13 = 1, swaps the pixels from l502(w844) with data from CPU bus
w846     Opposite of w836, set when about to begin a new 8x1 sprite silver
w847     Set to swap the pixels in w843 (see w844)
w848     H Timing signal: any sprite tile fetch, 1 dot later (from l141 and l156)
w849     w848, delayed by 4 dots if m5 or 5 dots if m4 (goes to l511)
w850     Detect when viewport just ends, for sprite rendering (negative edge detection for l512->l513, goes to l514)
w851     Set during sprite drawing when X[2:0] is +1px (within an 8px boundary)
w852     (low logic) Select pixels #0-#1 for test write to line buffer (writing to test reg 8 while $C00018[7:6] == 00)
w853     (low logic) Select pixels #2-#3 for test write to line buffer (writing to test reg 8 while $C00018[7:6] == 01)
w854     (low logic) Select pixels #4-#5 for test write to line buffer (writing to test reg 8 while $C00018[7:6] == 10)
w855     (low logic) Select pixels #6-#7 for test write to line buffer (writing to test reg 8 while $C00018[7:6] == 11)
w856     Writing test reg 8 pixels #0-#1 OR w818 == 0
w857     Writing test reg 8 pixels #2-#3 OR w818 == 0
w858     Writing test reg 8 pixels #4-#5 OR w818 == 0
w859     Writing test reg 8 pixels #6-#7 OR w818 == 0
w860     Set when X is right to store pixel #0 when rotating sprite pixels
w861     Set when X is right to store pixel #1 when rotating sprite pixels
w862     Set when X is right to store pixel #2 when rotating sprite pixels
w863     Set when X is right to store pixel #3 when rotating sprite pixels
w864     Set when X is right to store pixel #5 when rotating sprite pixels (yes #4 is out of sequence, see w828)
w865     Set when X is right to store pixel #6 when rotating sprite pixels
w866     Set when X is right to store pixel #7 when rotating sprite pixels
w867     Set during sprite drawing when X[2:0] is +2px (within an 8px boundary)
w868     Set during sprite drawing when X[2:0] is +3px (within an 8px boundary)
w869     Set during sprite drawing when X[2:0] is +4px (within an 8px boundary)
w870     Set during sprite drawing when X[2:0] is +6px (within an 8px boundary)
w871     Set during sprite drawing when X[2:0] is +7px (within an 8px boundary)
w872     Set to store pixel #0 when rotating sprite pixels (to l515, on clk1)
w873     Sprite x[2:0] == 1 or w877 (used to simplify logic with w860..w866)
w874     Set to store pixel #1 when rotating sprite pixels (to l516, on clk1)
w875     Set to store pixel #2 when rotating sprite pixels (to l517, on clk1)
w876     Sprite x[2:0] == 3 or w877 (used to simplify logic with w860..w866)
w877     Forces all 8 sprite pixels to be "rotated" already (for test reg 0 bit 13, dunno when it triggers)
w878     Set to store pixel #3 when rotating sprite pixels (to l518, on clk1)
w879     Set to store pixel #4 when rotating sprite pixels (to l519, on clk1)
w880     Sprite x[2:0] == 5 or w877 (used to simplify logic with w860..w866)
w881     Set to store pixel #5 when rotating sprite pixels (to l520, on clk1)
w882     Set to store pixel #6 when rotating sprite pixels (to l521, on clk1)
w883     Sprite x[2:0] == 7 or w877 (used to simplify logic with w860..w866)
w884     Set to store pixel #7 when rotating sprite pixels (to l522, on clk1)
w885     Set when rotated sprite pixels are ready to be copied into l523..l530
w886     Set if we determined we have to draw sprite pixel #0 within a 8px boundary
w887     Set if we determined we have to draw sprite pixel #1 within a 8px boundary
w888     Set if we determined we have to draw sprite pixel #2 within a 8px boundary
w889     Set if we determined we have to draw sprite pixel #3 within a 8px boundary
w890     Set if we determined we have to draw sprite pixel #4 within a 8px boundary
w891     Set if we determined we have to draw sprite pixel #5 within a 8px boundary
w892     Set if we determined we have to draw sprite pixel #6 within a 8px boundary
w893     Set if we determined we have to draw sprite pixel #7 within a 8px boundary
w902     Determines whether line buffer pixel #0 will be written (latched in l538)
w903     Determines whether line buffer pixel #1 will be written (latched in l539)
w904     Determines whether line buffer pixel #2 will be written (latched in l540)
w905     Determines whether line buffer pixel #3 will be written (latched in l541)
w906     Determines whether line buffer pixel #4 will be written (latched in l542)
w907     Determines whether line buffer pixel #5 will be written (latched in l543)
w908     Determines whether line buffer pixel #6 will be written (latched in l544)
w909     Determines whether line buffer pixel #7 will be written (latched in l545)
w910     Line buffer write enable pixel #0
w911     Line buffer write enable pixel #1
w912     Line buffer write enable pixel #2
w913     Line buffer write enable pixel #3
w914     Line buffer write enable pixel #4
w915     Line buffer write enable pixel #5
w916     Line buffer write enable pixel #6
w917     Line buffer write enable pixel #7
w918     Old sprite data pixel #0 opaque
w919     Old sprite data pixel #1 opaque
w920     Old sprite data pixel #2 opaque
w921     Old sprite data pixel #3 opaque
w922     Old sprite data pixel #4 opaque
w923     Old sprite data pixel #5 opaque
w924     Old sprite data pixel #6 opaque
w925     Old sprite data pixel #7 opaque
w926     New and old sprite px #0 opaque + output mask for this pixel? (check for sprite collision)
w927     New and old sprite px #1 opaque + output mask for this pixel? (check for sprite collision)
w928     New and old sprite px #2 opaque + output mask for this pixel? (check for sprite collision)
w929     New and old sprite px #3 opaque + output mask for this pixel? (check for sprite collision)
w930     New and old sprite px #4 opaque + output mask for this pixel? (check for sprite collision)
w931     New and old sprite px #5 opaque + output mask for this pixel? (check for sprite collision)
w932     New and old sprite px #6 opaque + output mask for this pixel? (check for sprite collision)
w933     New and old sprite px #7 opaque + output mask for this pixel? (check for sprite collision)
w934     New sprite data pixel #0 opaque
w935     New sprite data pixel #1 opaque
w936     New sprite data pixel #2 opaque
w937     New sprite data pixel #3 opaque
w938     New sprite data pixel #4 opaque
w939     New sprite data pixel #5 opaque
w940     New sprite data pixel #6 opaque
w941     New sprite data pixel #7 opaque
w942     Can sprite pixel #0 be rewritten?
w943     Can sprite pixel #1 be rewritten?
w944     Can sprite pixel #2 be rewritten?
w945     Can sprite pixel #3 be rewritten?
w946     Can sprite pixel #4 be rewritten?
w947     Can sprite pixel #5 be rewritten?
w948     Can sprite pixel #6 be rewritten?
w949     Can sprite pixel #7 be rewritten?
w950     Always 0, would have selected between sprite underdraw or overdraw
w951     ~w820
w952     reg_test_18[7:6] == 2'h0 (debug, selects a pair of sprite layer pixels?)
w953     reg_test_18[7:6] == 2'h1 (debug, selects a pair of sprite layer pixels?)
w954     reg_test_18[7:6] == 2'h2 (debug, selects a pair of sprite layer pixels?)
w955     reg_test_18[7:6] == 2'h3 (debug, selects a pair of sprite layer pixels?)
w956     Palette bit 0 of chosen sprite layer pixel (even)
w957     Palette bit 1 of chosen sprite layer pixel (even)
w958     Priority bit of chosen sprite layer pixel (even)
w959     Color bit 0 of chosen sprite layer pixel (even)
w960     Color bit 1 of chosen sprite layer pixel (even)
w961     Color bit 2 of chosen sprite layer pixel (even)
w962     Color bit 3 of chosen sprite layer pixel (even)
w963     Palette bit 0 of chosen sprite layer pixel (odd)
w964     Palette bit 1 of chosen sprite layer pixel (odd)
w965     Priority bit of chosen sprite layer pixel (odd)
w966     Color bit 0 of chosen sprite layer pixel (odd)
w967     Color bit 1 of chosen sprite layer pixel (odd)
w968     Color bit 2 of chosen sprite layer pixel (odd)
w969     Color bit 3 of chosen sprite layer pixel (odd)
w970     Sprite layer palette from line buffer? (delayed by 1 dot in mode 5, see l553)
w971     Sprite layer priority from line buffer? (delayed by 1 dot in mode 5, see l554)
w972     Sprite layer color from line buffer? (delayed by 1 dot in mode 5, see l555)
w973     Final sprite layer priority (forced to 0 in mode 4, used in layer mixing)
w974     Final sprite palette (forced to 01 in mode 4, used in layer mixing)
w975     l556 == 2'h3 (sprite S/H palette check)
w976     l558 != 4'h0 (sprite not transparent pixel check)
w977     l558 == 4'hE (sprite S/H highlight pixel check)
w978     l558 == 4'hF (sprite S/H shadow pixel check)
w979     Line buffer write data priority (2nd, 4th, 6th, 8th pixels)
w980     Line buffer write data palette (2nd, 4th, 6th, 8th pixels)
w982     Line buffer write data priority (1st, 3rd, 5th, 7th pixels)
w983     Line buffer write data palette (1st, 3rd, 5th, 7th pixels)
w985     VRAM read enable (high logic)
w986     VRAM lower byte write enable (high logic), goes to /WE0 (as low logic)
w987     VRAM upper byte write enable (high logic), goes to /WE1 (as low logic)
w988     1 = assert VRAM CAS (/CAS1 goes low)
w989     1 = assert VRAM RAS (/RAS1 goes low)
w990     Control pin direction of RD and AD (0: output, 1: input, I think?)
w991     VRAM write to lower byte (from w286, or l571 which is latched w286)
w998     Enable latching RD_i/AD_i in l598/l599
w999     VRAM write to upper byte (from w288, or l585 which is latched w288)
w1007    Alternate between /SE0 and /SE1 in 128k mode, or stick to /SE0 only when not 128k
w1008    H Timing signal: refresh slot (l588 OR l589, introduces 2 dots of latency, pulse is 2 dots long)
w1009    /YS signal (see w1082 too)
w1010    Used for VRAM address computation (bit 1 in m5)
w1011    Used for VRAM address computation (w1010 OR bit 9 in m4)
w1012    Physical VRAM address (upper half, latched into l592)
w1013    VRAM address MSB to use
w1014    Physical VRAM address (lower half, latched into l593)
w1018    VRAM address bus output (connected to AD_o[7:0])
w1019    VRAM data bus output (connected to RD_o[7:0])
w1020    Set if sprite collision detected (any of w926~w933 set), goes to l600->t11
w1021    Set on CRAM bus access
w1022    [priority logic]  a_pri ?  s_pri : ~b_pri
w1023    [priority logic] ~a_pri &  s_pri &  b_pri
w1024    [priority logic]  a_pri & ~s_pri & ~b_pri
w1025    [priority logic] ~a_pri & ~s_pri &  b_pri
w1026    [priority logic]  a_pri & ~s_pri &  b_pri
w1027    [priority logic] ~a_pri & ~s_pri & ~b_pri & S/H enable
w1028    [priority logic] ~a_pri &  s_pri & ~b_pri & S/H enable
w1029    S/H enable
w1030    Is it a S/H sprite pixel?
w1031    Set if sprite layer is transparent in this pixel
w1032    Set if plane A layer is transparent in this pixel
w1033    Set if plane B layer is transparent in this pixel
w1034    reg_test0[8:7] == 2'h1; (layer override: sprite)
w1035    reg_test0[8:7] == 2'h2; (layer override: plane A)
w1036    reg_test0[8:7] == 2'h3; (layer override: plane B)
w1037    reg_test0[8:7] == 2'h0; (layer override: none)
w1038    [priority logic] A=hi B=lo S=lo, but plane A transparent (S wins) (part of w1041)
w1039    [priority logic] A=lo B=lo S=hi, but plane B transparent (S wins) (part of w1041)
w1040    [priority logic] A=hi B=hi S=lo, but plane A & B transparent (S wins) (part of w1041)
w1041    Set when sprite is highest priority layer (ignoring its transparent pixels?)
w1042    Set to output sprite plane to color bus, ignoring S/H logic (goes to w1043)
w1043    Set to output sprite plane to color bus, accounting for S/H logic (goes to w1044)
w1044    Set to output sprite plane to color bus (after override is applied, goes to l603)
w1045    Set if output sprite plane and is a S/H sprite pixel
w1046    [priority logic] A=lo B=lo, or A=hi S=hi, but sprite transparent (A wins) (part of w1049)
w1047    [priority logic] A=lo B=hi S=hi, but plane B and sprite transparent (A wins) (part of w1049)
w1048    [priority logic] A=lo B=hi S=lo, but plane B and sprite transparent (A wins) (part of w1049)
w1049    Set when plane A is highest priority layer (ignoring its transparent pixels?)
w1050    Set to output plane A to color bus (goes to w1051)
w1051    Set to output plane A to color bus (after override is applied, goes to l604)
w1052    [priority logic] A=lo B=hi S=hi, but sprite transparent (B wins) (part of w1056)
w1053    [priority logic] A=hi B=hi S=lo, but plane A transparent (B wins) (part of w1056)
w1054    [priority logic] A=lo AND B=lo, or A=hi AND S=hi, but plane A and sprite transparent (B wins) (part of w1056)
w1055    [priority logic] A=hi B=lo S=lo, but plane A and sprite transparent (B wins) (part of w1056)
w1056    Set when plane B is highest priority layer (ignoring its transparent pixels?)
w1057    Set to output plane B to color bus (goes to w1058)
w1058    Set to output plane B to color bus (after override is applied, goes to l605)
w1059    Set if all layers are transparent
w1060    Set to output background plane to color bus (goes to w1061)
w1061    Set to output background plane to color bus (after override is applied, goes to l606)
w1062    Plane output enable? ("in visible viewport" AND reg_test0[6] == 0)
w1063    Set if output sprite plane and sprite color index != 4'hE
w1064    Usually bright pixel? (plane A/B high priority and/or S/H disabled)
w1065    Shadow or highlight pixel color index (part of w1030's expression)
w1066    Highlight flag (latched into l607, used 4 dots later in l630)
w1067    Shadow flag (goes to w1068 to merge with l618)
w1068    Shadow flag + in viewport (latched into l608, used 4 dots later in l629)
w1069    Allow background color bit 6 to override shadow flag when test reg 0 bit 6 is set
w1070    Allow background color bit 7 to override highlight flag when test reg 0 bit 6 is set
w1072    CRAM CPU access in mode 5
w1073    CRAM CPU access in mode 4
w1074    ??? (involves SPA/B)
w1075    Set when going to output viewport pixels? (selects mode 4 or mode 5 timing, from 389 and l616)
w1076    CRAM address to access (goes to l617)
w1077    Set if output color is transparent, used for computing /YS (latched in l619)
w1078    CRAM write: data for "red" bits (internal bits 2:0)
w1079    CRAM write: data for "green" bits (internal bits 5:3)
w1080    Used to time CRAM read output (limits l623_3 to hclk1)
w1081    Enable color output on RGB pins (goes to l624)
w1082    Set when displaying transparent color (ignoring SPA/B)
w1083    Red color bit 1 (mux for m4/m5)
w1084    Red color bit 2 (mux for m4/m5)
w1085    Green color bit 1 (mux for m4/m5)
w1086    Green color bit 2 (mux for m4/m5)
w1087    Blue color bit 1 (mux for m4/m5)
w1088    Blue color bit 2 (mux for m4/m5)
w1089    Red color bit 1 masked by M4 and blanking
w1090    Red color bit 2 masked by M4 and blanking
w1091    Green color bit 1 masked by M4 and blanking
w1092    Green color bit 2 masked by M4 and blanking
w1093    Blue color bit 1 masked by M4 and blanking
w1094    Blue color bit 2 masked by M4 and blanking
w1098    Blue color bit 0 masked by M5 and blanking
w1099    Green color bit 0 masked by M5 and blanking
w1100    Red color bit 0 masked by M5 and blanking
w1101    Normal color flag (see l630 for highlight) (for RGB DAC use only)
w1102    Shadow color flag (see l630 for highlight) (for RGB DAC use only)
w1103    Goes to the RGB DAC taps ([0] = red, [1] = green, [2] = blue)
w1108    (en1 for PSG noise shift register, loads the shifted data)
w1109    (en2 for PSG noise shift register, loads the existing data)
w1112    reg_test0[9] & reg_test0[11:10] != 2'h0 (PSG channel override: ch1)
w1113    reg_test0[9] & reg_test0[11:10] != 2'h1 (PSG channel override: ch2)
w1114    reg_test0[9] & reg_test0[11:10] != 2'h2 (PSG channel override: ch3)
w1115    reg_test0[9] & reg_test0[11:10] != 2'h3 (PSG channel override: ch4)
w1118    XOR feedback for PSG noise in "white noise" mode
w1119    Set if PSG noise register (excluding the MSB) is NOT all zeroes (meant for "periodic noise" maybe?)
w1120    Gates w1118's output when using "periodic noise" mode
w1135    Set when writing to PSG square channel #1 volume
w1136    Set when writing to PSG square channel #2 volume
w1137    Set when writing to PSG square channel #3 frequency
w1138    Set when writing to PSG square channel #2 frequency
w1139    Set when writing to PSG square channel #3 volume
w1140    Set when writing to PSG square channel #1 frequency
w1141    Set when writing to PSG noise channel volume
w1142    Set when writing to PSG noise channel type/pitch

mclk_clk1         MCLK/4 (50% cycle duty, --__ pattern)
mclk_clk2         MCLK/5 (60% cycle duty, ---__ pattern)
mclk_clk3         MCLK/7 (4/7 cycle duty, ----___ pattern)
mclk_clk4         MCLK/12 (50% cycle duty, ------______ pattern)
mclk_clk5         MCLK/15

prescaler_dff3    Used for MCLK/4 generation
prescaler_dff4    Used for MCLK/4 generation
prescaler_dff5    Used for MCLK/5 generation
prescaler_dff6    Used for MCLK/5 generation
prescaler_dff7    Used for MCLK/5 generation
prescaler_dff8    Used for MCLK/7 generation
prescaler_dff9    Used for MCLK/7 generation
prescaler_dff10   Used for MCLK/7 generation
prescaler_dff11   Used for MCLK/7 generation
prescaler_dff12   Used for MCLK/12 generation
prescaler_dff13   Used for MCLK/12 generation
prescaler_dff14   Used for MCLK/12 generation

dff3_l2  DMA in progress
dff22_l2 DMA transfer in progress (latched from t4)
dff23_l2 ??? (bit 0 of some value, incremented by ~t3, reset by w41)
dff24_l2 ??? (bit 1 of some value, incremented by ~t3, reset by w41)
dff25_l2 ??? (bit 2 of some value, incremented by ~t3, reset by w41)
dff26_l2 ??? (bit 3 of some value, incremented by ~t3, reset by w41)
dff27_l2 ??? (bit 4 of some value, incremented by ~t3, reset by w41)
dff28_l2 ??? (bit 5 of some value, incremented by ~t3, reset by w41)
dff29_l2 ??? (bit 6 of some value, incremented by ~t3, reset by w41)
dff30_l2 Pending external interrupt? (set by w58, reset by w49)
dff31_l2 Pending hblank interrupt? (set by w57, reset by w49)
dff32_l2 Pending vblank interrupt? (set by w60, reset by w49)

l1       H Timing signal: refresh slot (from l108, introduces 2 dots of latency)
l2       H Timing signal: refresh slot (from l1, introduces 3 dots of latency)
l3       H Timing signal: refresh slot (from l2, introduces 4 dots of latency)
l4       NOT set during a refresh slot for 4 dots
l5       Delays w267 by 1 dot
l6       ??? (affects output of MSB of source address in DMA transfer from ROM)
l7       (delays l6 by half a dot, inverted)
l8       (delays l7 by half a dot, uninverted)
l9       End of interrupt acknowledge (from w48, to l10)
l10      End of interrupt acknowledge (from l9, to l11)
l11      End of interrupt acknowledge (from l10)
l12      [has another use with w51] Used to reset t6 two dots after it's set (t6 -> l12 -> l13)
l13      [has another use with w52] Used to reset t6 two dots after it's set (t6 -> l12 -> l13)
l14      Clear sprite overflow and collision flags on vblank (F flag too if mode 4)
l18      Select between DATA and CTRL port for writes (latched when NOT writing the ports)
l19      Select between DATA and CTRL port for reads (latched when NOT reading the ports, used by w143)
l21      CPU access to DATA/CTRL detected, from 2.5 to 4.5 DCLK later
l22      CPU access to DATA/CTRL detected, from 2.0 to 4.0 DCLK later
l23      CPU access to DATA/CTRL detected, from 1.5 to 3.5 DCLK later (INVERTED!!)
l24      CPU access to DATA/CTRL detected, from 1.0 to 3.0 DCLK later
l25      CPU access to DATA/CTRL detected, from 0.5 to 2.5 DCLK later
l29      (from w177, 1 dot later) Not CRAM nor VSRAM selected for reading (from w201 and w202)
l30      (from w177, 2 dots later) Not CRAM nor VSRAM selected for reading (from w201 and w202)
l31      Register write enable pipeline (from l34, to w205)
l32      Register write enable pipeline (from w193, to l33 and l34)
l33      Register write enable pipeline (from l32, to l34)
l34      Register write enable pipeline (from l32 and l33, to l31)
l35      Current VRAM address (17-bit), likely used for the 2nd byte write of a word write to VRAM?
l36      FIFO address entry #1 (17-bit)
l37      FIFO address entry #0 (17-bit)
l38      FIFO address entry #3 (17-bit)
l39      FIFO address entry #2 (17-bit)
l40      (used to mask w18's first DCLK cycle for w249)
l42      Set when trying to write into FIFO (from w264, used to determine FIFO full flag in w252)
l43      Set when FIFO is full (from w252, used to determine FIFO full flag in w252)
l44      Time to flush FIFO entry (free access slot and FIFO not empty) (delayed 2 dots from w269)
l45      (used for rising edge detection of l44)
l46      Status port EMPT bit (0 = FIFO has data, 1 = FIFO is empty)
l47      ??? (stores VRAM address bit 0)
l48      Finish DMA transfer (from w244, to w4)
l49      Time to flush FIFO entry (free access slot and FIFO not empty) (delayed 1 dot from w269)
l50      Selects between live flags and FIFO flags (used during DMA fill) (from w272)
l51      FIFO write index (2-bit, incremented by w264)
l52      FIFO read index (bit -1, yes "half" an entry)
l53      FIFO read index (bit 0)
l54      FIFO read index (bit 1)
l55      FIFO upper byte OK entry #3 (stores w277)
l56      FIFO upper byte OK entry #2 (stores w277)
l57      FIFO upper byte OK entry #1 (stores w277)
l58      FIFO upper byte OK entry #0 (stores w277)
l59      FIFO lower byte OK entry #3 (stores w279)
l60      FIFO lower byte OK entry #2 (stores w279)
l61      FIFO lower byte OK entry #1 (stores w279)
l62      FIFO lower byte OK entry #0 (stores w279)
l63      FIFO CD0 entry #3
l64      FIFO CD0 entry #2
l65      FIFO CD0 entry #1
l66      FIFO CD0 entry #0
l67      FIFO CD1 entry #3
l68      FIFO CD1 entry #2
l69      FIFO CD1 entry #1
l70      FIFO CD1 entry #0
l71      FIFO CD2 entry #3
l72      FIFO CD2 entry #2
l73      FIFO CD2 entry #1
l74      FIFO CD2 entry #0
l75      FIFO CD3 entry #3
l76      FIFO CD3 entry #2
l77      FIFO CD3 entry #1
l78      FIFO CD3 entry #0
l79      Lightgun input (to l80, used for edge detection)
l80      Lightgun input (from l79, used for edge detection)
l81      External interrupt pulse (one cycle long!) (from w335)
l83      VRAM address bit 0? (comes from l47)
l84      VRAM address bit 0? (comes from l83 <- l47)
l85      VRAM address bit 0? (comes from l84 <- l83 <- l47)
l88      Gate latching for upper byte of VRAM read (from w341)
l89      Gate latching for lower byte of VRAM read (from w342)
l90      Frozen V counter (exposed over $C00008)
l91      Frozen H counter (exposed over $C00009)
l92      Lower byte of a DATA read (latched from w348)
l93      Upper byte of a DATA read (latched from w349)
l94      Value to write to FIFO entry data (upper byte)
l95      Value to write to FIFO entry data (lower byte)
l96      FIFO entry #1 data (upper byte)
l97      FIFO entry #1 data (lower byte)
l98      FIFO entry #2 data (upper byte)
l99      FIFO entry #2 data (lower byte)
l100     FIFO entry #3 data (upper byte)
l101     FIFO entry #3 data (lower byte)
l102     FIFO entry #0 data (upper byte)
l103     FIFO entry #0 data (lower byte)
l104     Latch for data to write? Comes from FIFO's data output, used in a lot of places
l105     V counter
l106     H counter
l107     Vsync (for mode 5, delayed from l663 by 8 dots)
l108     H Timing signal: refresh slot (from w476, introduces 1 dot of latency)
l109     Free VRAM slot (CPU access allowed) (latched from w359)
l110     H Timing signal: H counter = 0 (latched from w504, introduces 1 dot of latency)
l111     H Timing signal: H position of middle of the scanline (1 dot wide, used for interlaced mode, from w503)
l112     H Timing signal: H counter wraparound (from w490, introduces 1 dot of latency)
l113     Used to do edge detection of l121
l115     H Timing signal: increment V counter (from w502, turned high logic), latch window settings, hscroll in m4
l117     H Timing signal: VSRAM read in full vscroll, when F flag is cleared (from w505), 1 dot later, inverted
l118     H Timing signal: fetch plane A tilemap data (from w477), 1 dot later
l119     H Timing signal: fetch plane B tilemap data (from w478), 1 dot later
l120     CSYNC pin input
l121     External pulse for H counter wraparound? (whatever w376 is)
l122     H Timing signal: (whatever w492 is, goes to l173)
l123     H Timing signal: end of long hsync pulse (see w501)
l124     H Timing signal: VSRAM read in column vscroll (from w506), 1 dot later
l125     H Timing signal: fetch plane A or B tile data (1st half) (from w479)
l126     H Timing signal: fetch plane A or B tile data (2nd half) (from w480)
l127     Intended /CSYNC output delayed by 8 dots, for use in mode 5
l128     /CSYNC output (inverted)
l129     HBLANK flag in mode 4
l130     H Timing signal: start of horizontal display (end of left border) (see w493)
l131     H Timing signal: start of hsync (see w500)
l134     H Timing signal: fetch sprite table data (see w481)
l135     Delays hsync pulse by 7 dots (for mode 5 use, from w421)
l136     Hsync (high logic)
l137     H Timing signal: end of horizontal display (start of right border) (see w494)
l138     H Timing signal: end of short hsync (see w499)
l139     (used to stretch w410 for one more dot, see w403)
l141     H Timing signal: fetch sprite tile (see w482), 1 dot later
l142     H Timing signal: (see w489), 1 dot later
l143     H Timing signal: start of hblank (see w495)
l144     H Timing signal: start of mid-line hsync (see w498)
l145     H Timing signal: 3px after sprite X & tile ID fetch in mode 5 (from w510)
l146     H Timing signal: (whatever w509 is, maybe same as w510 but mode 4?)
l147     H Timing signal: m4 fetch sprite Y data, m5 scan sprite Y data? (see w487)
l148     H Timing signal: hscroll table fetch (pipeline goes to w642->l314->l315->l316)
l149     External HSync pin input
l152     End of hblank
l153     H Timing signal: half a scanline before end of horizontal display (from w497, delayed one dot)
l154     H Timing signal: H counter = 507 (-5), used for plane B? (from w511, delayed one dot)
l155     H Timing signal: m4 sprite X / tile ID fetches? (active scan only, passive scan is weird) (from w485)
l156     H Timing signal: m4 sprite tile fetch (1st half), 1 dot later
l157     Hsync pulse (before it's affected by reg $00 bit 3, goes to w421)
l158     HBLANK flag in mode 5 (delayed by 8 dots compared to mode 4 l129)
l160     ??? (replaces csync if reg $00 bit 3 == 1, goes to w421)
l161     (w420 delayed until next dot, used for edge detection)
l162     V Timing signal: line 511 (from w475, turned high logic)
l163     V Timing signal: ??? (always 3 lines after w473, end of the extra sync pulses maybe?) (from w474)
l164     V Timing signal: end of vsync / start of top TV vblank (from w473)
l165     V Timing signal: start of vsync (always 3 lines before w473) (from w472)
l167     V Timing signal: start of top border / end of top TV blank (from w471)
l168     Set even/odd flag (force odd flag)
l169     V Timing signal: end of bottom border / start of bottom TV blank (from w470)
l170     (low logic) Start of logic vblank (from w469)
l172     End of logic vblank (from ~w468)
l173     H Timing signal: (whatever w492 is, from l122)
l174     V Timing signal: V counter wraparound point (from w467), 1 dot later
l176     (used for edge detection of l175)
l178     Bit 3 of H counter (related to tilemap fetches?)
l179     Register $09 (mode 4 vscroll)
l180     Holds data read from VSRAM bus (updated when w516 goes high)
l181     Data to write to VSRAM
l182     Data to write to VSRAM (bits 10:8, goes to l181)
l183     Enables VSRAM output to the VRAM bus
l184     VScroll value to work with (VSRAM output in m5, reg $09 in m4) (plane A?) (from w515, latched when w517)
l186     Clear when vscroll inhibit should kick in, set otherwise (from w519)
l187     Latches window left/right split select (copied from reg $11 on w542)
l188     Latches window X split position (copied from reg $11 on w542)
l189     Latches window up/down split select (copied from reg $12 on w544)
l190     Latches window Y split position (copied from reg $12 on w544)
l191     Bits 7:0 of horizontal scroll in mode 5 for plane A
l192     Bits 7:0 of horizontal scroll in mode 5 for plane B
l193     Horizontal scroll in mode 4 (copied from reg $08)
l194     Bits 9:8 of horizontal scroll in mode 5 for plane A
l195     Bits 9:8 of horizontal scroll in mode 5 for plane B
l196     VRAM address output enable: bits 4:0 of plane A/B tile fetch
l197     Fetching plane A (0) or plane B (1)?
l198     Bit 1 of plane A/B tile address to fetch (inverted)
l199     VRAM address output enable: bits 13:5 of 1st plane A/B tile fetch (from w551)
l200     Set when we want to set the address for a plane B tile name fetch (from w556, goes to w558)
l201     Set when we want to set the address for a plane A tile name fetch (from w557, goes to w558)
l202     VRAM address output enable: window plane tile name fetch (from w559)
l203     (pipeline, goes to l204)
l204     (pipeline, goes to l205)
l205     Set to start fetching of tilemap table data (see l251)
l206     VSRAM read enable (from w201, to l209 and VSRAM address mux)
l207     VSRAM write enable, upper byte (from w323, to l210 and VSRAM address mux)
l208     VSRAM write enable, lower byte (from w324, to l211 and VSRAM address mux)
l209     VSRAM read latch enable (from l206, to w516)
l210     VSRAM write enable, upper byte (bits 10:8)
l211     VSRAM write enable, lower byte (bits 7:0)
l212     VSRAM address to access (from w626)
l213     Set while fetching hscroll plane A bits 7:0 (see w570)
l214     Set while fetching hscroll plane A bits 9:8 (see w571)
l215     Set while fetching hscroll plane B bits 7:0 (see w572)
l216     Set while fetching hscroll plane B bits 9:8 (see w573)
l217     Selects plane A (0) or window (1) for output (from w541, used by vscroll logic in w576)
l218     VRAM address output enable: bits 16:5 of 2nd plane A/B tile fetch (from w582)
l219     Plane A/B 1st tilemap fetch lower byte
l220     Plane A/B 1st tilemap fetch upper byte
l221     Plane A/B 2nd tilemap fetch lower byte
l222     Plane A/B 2nd tilemap fetch upper byte
l223     4th byte of 2nd tile of plane A (m5 pixels 4:5) as it's being latched from VRAM
l224     3rd byte of 2nd tile of plane A (m5 pixels 6:7) as it's being latched from VRAM
l225     2nd byte of 2nd tile of plane A (m5 pixels 0:1) as it's being latched from VRAM
l226     1st byte of 2nd tile of plane A (m5 pixels 2:3) as it's being latched from VRAM
l227     When to latch 1st byte of 2nd tile of plane A from VRAM (enables l226)
l228     When to latch 2nd byte of 2nd tile of plane A from VRAM (enables l225)
l229     When to latch 3rd byte of 2nd tile of plane A from VRAM (enables l224)
l230     When to latch 4th byte of 2nd tile of plane A from VRAM (enables l223)
l236     [???] Amount to shift plane to the right? (loaded with bits 3:0 of hscroll)
l237     Plane B tile pixels 7:6
l238     Plane B tile pixels 5:4
l239     Plane B tile pixels 3:2 (m5), plane A bitplane 3 (m4)
l240     Plane B tile pixels 1:0 (m5), plane A bitplane 2 (m4)
l241     [???] X offset within plane (A?) output? (loaded with l236 on w614; counts up every dot)
l242     [???] (enables write to l236)
l243     4th byte of 1st tile of plane A (m5 pixels 4:5) as it's being latched from VRAM
l244     3rd byte of 1st tile of plane A (m5 pixels 6:7) as it's being latched from VRAM
l245     2nd byte of 1st tile of plane A (m5 pixels 0:1) as it's being latched from VRAM
l246     1st byte of 1st tile of plane A (m5 pixels 2:3) as it's being latched from VRAM
l247     When to latch 1st byte of 1st tile of plane A from VRAM (enables l246)
l248     When to latch 2nd byte of 1st tile of plane A from VRAM (enables l245)
l249     When to latch 3rd byte of 1st tile of plane A from VRAM (enables l244)
l250     When to latch 4th byte of 1st tile of plane A from VRAM (enables l243)
l251     Set while fetching tilemap data (1st tile) bits 7:0 (see w615)
l252     Set while fetching tilemap data (1st tile) bits 15:8 (see w616)
l253     Set while fetching tilemap data (2nd tile) bits 7:0 (see w617)
l254     Set while fetching tilemap data (2nd tile) bits 15:8 (see w618)
l259     [???] On w591, taken from fetching tilemap name: {pri:a,pri:b, pal:a[1],pal:b[1], pal:a[0],pal:b[0], hf:a,hf:b}
l261     Plane A tile pixels 7:6
l262     Plane A tile pixels 5:4
l263     Plane A tile pixels 3:2 (m5), plane A bitplane 1 (m4)
l264     Plane A tile pixels 1:0 (m5), plane A bitplane 0 (m4)
l267     Used to delay signal for latch 2nd tile of plane A
l268     Used to delay signal for latch 2nd tile of plane A
l269     Plane A color index to show (from w607, to l270 (layer mux), introduces 1 dot of delay)
l270     Plane A color index to show (from l269, to color bus mux, introduces another dot of delay)
l271     Plane A color palette to show (from w604;w603, to l272)
l272     Plane A color palette to show (from l271, to color bus mux)
l273     Plane A priority to show (from w605, to l274 and mux block)
l274     Plane A priority to show (from l273, to color bus mux)
l275     4th byte of 1st tile of plane B (m5 pixels 4:5) as it's being latched from VRAM
l276     3rd byte of 1st tile of plane B (m5 pixels 6:7) as it's being latched from VRAM
l277     2nd byte of 1st tile of plane B (m5 pixels 0:1) as it's being latched from VRAM
l278     1st byte of 1st tile of plane B (m5 pixels 2:3) as it's being latched from VRAM
l283     When to latch 1st byte of 1st tile of plane B from VRAM (enables l278)
l284     When to latch 2nd byte of 1st tile of plane B from VRAM (enables l277)
l285     When to latch 3rd byte of 1st tile of plane B from VRAM (enables l276)
l286     When to latch 4th byte of 1st tile of plane B from VRAM (enables l275)
l291     [???] On w631, taken from fetching tilemap name: {pri:a,pri:b, pal:a[1],pal:b[1], pal:a[0],pal:b[0], hf:a,hf:b}
l293     VRAM address bits 6:1 (used in VSRAM block)
l294     4th byte of 2nd tile of plane B (m5 pixels 4:5) as it's being latched from VRAM
l295     3rd byte of 2nd tile of plane B (m5 pixels 6:7) as it's being latched from VRAM
l296     2nd byte of 2nd tile of plane B (m5 pixels 0:1) as it's being latched from VRAM
l297     1st byte of 2nd tile of plane B (m5 pixels 2:3) as it's being latched from VRAM
l298     When to latch 1st byte of 2nd tile of plane B from VRAM (enables l297)
l299     When to latch 2nd byte of 2nd tile of plane B from VRAM (enables l296)
l300     When to latch 3rd byte of 2nd tile of plane B from VRAM (enables l295)
l301     When to latch 4th byte of 2nd tile of plane B from VRAM (enables l294)
l311     [???] X offset within plane (B?) output? (loaded with same value as l236 but MSB inverted; counts up every dot)
l312     Used to delay signal for latch 2nd tile of plane B
l313     Used to delay signal for latch 2nd tile of plane B
l314     (pipeline, goes to l315) Set to output hscroll address (via w643)
l315     (pipeline, goes to l316)
l316     Set to start fetching of hscroll table data (see l213)
l318     Plane B color index to show (from w647, to l319)
l319     Plane B color index to show (from l318, to color bus mux)
l320     Plane B priority to show (from w637, to l321 and mux block)
l321     Plane B priority to show (from l320, to color bus mux)
l322     Plane B color palette to show (from w636;w635, to l323)
l323     Plane B color palette to show (from l322, to color bus mux)
l325     Latch VRAM address bit 1, used by w650 to tell which word of a sprite entry is cached (Y or size/link)
l327     Sprite size (10:7) and link (6:0) (latched from cache, goes to l328)
l328     Sprite size (10:7) and link (6:0), inverted (from l327, goes to l332)
l332     Sprite size (10:7) and link (6:0), inverted (from l328, latched on w652)
l333     Set to latch sprite size and link from l328 into l332 (narrowed down in w652)
l336     Sprite width bit 1 (adjusted for both mode 5 and 4) (from l332, goes to l379)
l337     Sprite width bit 0 (adjusted for both mode 5 and 4) (from l332, goes to l379)
l338     Sprite height bit 1 (adjusted for both mode 5 and 4) (from w656, goes to l379)
l339     Sprite height bit 0 (adjusted for both mode 5 and 4) (from w657, goes to l379)
l340     Sprite Y position (latched from w666)
l341     Sprite Y position after offset applied (from 1+l340+w653 -> w662), bits 9:6 inverted for some reason
l342     Sprite Y position from VRAM for mode 4 (latched when w661 set, used in m4: see w666 and w677)
l343     Sprite Y position, inverted (from w680) (latched when w660 set)
l344     Sprite Y position, NOT inverted (from l343, 0.5 dots later)
l345     Mode 5 sprite Y position (latched from the cache, 1 dot later)
l346     Mode 5 sprite Y position, inverted (latched from l345, 0.5 dots later)
l351     Current sprite ID being processed
l352     Used to stretch out l353 one cycle longer
l363     Is VRAM address within sprite cache range (upper byte) (from w693)
l364     Is VRAM address within sprite cache range (lower byte) (from w694)
l368     Set if l367(?) OR sprite render list index reached 20 (from w698), used in w700
l371     Sprite to render index (to w697->sprite queue index)
l372     Set if hpos = 258+2 (H32) or 322+2 (H40), 2 dots later than when F flag is cleared (from w360)
l373     Resets sprite render list index back to 0 (sets l371 = 0)
l376     Delays the output from w743 by 10 dots (20 DCLK), output goes to w714
l379     Holds sprite size when about to insert one into the sprite render list
l380     Sprite Y position bits 6:0 after offset applied (from 1+l340+w653 -> w662), before V flip is applied
l382     Related to sprite fetch timing? (from w418, from l145 and l155, goes to l410)
l386     m5: sprite X 1st byte, m4: sprite Y 1st byte; latched from VRAM on w745
l387     m5: sprite tile ID 1st byte, m4: sprite Y 2nd byte; latched from VRAM on w746
l388     Shift register holding Y row offsets for sprites in mode 4 (bit 0, 10 entries)
l389     Shift register holding Y row offsets for sprites in mode 4 (bit 1, 10 entries)
l390     Shift register holding Y row offsets for sprites in mode 4 (bit 2, 10 entries)
l391     Shift register holding Y row offsets for sprites in mode 4 (bit 3, 10 entries)
l392     Set 1 dot later than l394, used to control timing of reading sprite data into l386
l397     Used to delay w417 by one dot (see w750 for details)
l398     Sprite table index to access (from w696, to l399)
l399     Sprite table index to access (from l398, to l400)
l400     Sprite table index to access (from l399, to l403..l409 via w752)
l401     Select which sprite of a pair to read in mode 4
l403     Sprite table index to read, bit 0 (from l400 via w752, to w757); 20 (H40) or 16 (H32) entries
l404     Sprite table index to read, bit 1 (from l400 via w752, to w757); 20 (H40) or 16 (H32) entries
l405     Sprite table index to read, bit 2 (from l400 via w752, to w757); 20 (H40) or 16 (H32) entries
l406     Sprite table index to read, bit 3 (from l400 via w752, to w757); 20 (H40) or 16 (H32) entries
l407     Sprite table index to read, bit 4 (from l400 via w752, to w757); 20 (H40) or 16 (H32) entries
l408     Sprite table index to read, bit 5 (from l400 via w752, to w757); 20 (H40) or 16 (H32) entries
l409     Sprite table index to read, bit 6 (from l400 via w752, to w757); 20 (H40) or 16 (H32) entries
l410     ??? (shift register 20 bits long, clocked every dot, tied to sprite rendering, maybe to the above entries?)
l413     Sprite hflip latch
l414     Sprite palette latch
l415     Sprite priority latch
l416     Sprite width latch
l417     Sprite height latch
l418     Sprite Y offset latch (goes to VRAM address)
l419     (one dot later than l511, toggles l421 when set)
l420     Number of 8x1 sprite slices left? (loaded with sprite width latch *negated*, incremented by l141)
l421     Picks which byte is used for base sprite X in mode 4 (reset by w360, toggled by l419, goes to l422)
l422     Picks which byte is used for base sprite X in mode 4 (l435 or l436) (the mux is w788)
l423     [???] (delays t42 by a dot)
l424     Sprite pattern latch
l425     Sprite X coordinate latch, mode 5
l426     [???] (from w776) (gates something related to sprites queued for render?)
l427     UNUSED, latched from w777 but goes nowhere
l428     Enables VRAM address when reading 8x1px for a sprite for mode 5
l429     [???] Set if sprite X is not 0 (latched from w782)
l431     H Timing signal: fetch sprite tile (from l141), 2 dots later
l435     Latch to hold input from VRAM, 1st byte (sprite X position for mode 4?)
l436     m5: sprite X 2nd byte, m4: sprite X 2nd byte?; latched from VRAM on w744
l437     Base sprite X coordinate in mode 4 (for w799)
l438     (from w773, 1 dot delay)
l439     Sprite hflip latch (11 DCLK later than l413)
l440     Sprite palette latch (11 DCLK later than l414)
l441     Sprite priority latch (11 DCLK later than l415)
l442     Sprite width latch (11 DCLK later than l416)
l443     Sprite X coordinate latch, mode 5 (11 DCLK later than l425)
l444     Flag indicating whether a new sprite started being drawn? (used by w801)
l445     Same as l498 (from l454), 2 cycles later
l446     (from w800) Initial(?) X column for a sprite in the linebuffer (in 8px steps) (-128px offset is applied here!!)
l447     (from w802) Next linebuffer address to write to? (derived from w800 and regularly incremented or decremented by 1)
l448     (latches w795 to pass to l449)
l449     Working sprite hflip (from w795->l448, used to determine drawing direction)
l450     Sprite priority latched from l441, written to l451 when w803 is set
l451     Sprite priority latched from l441->l450, updated when w803 is set, goes to w811
l452     Sprite palette latched from l440, written to l453 when w803 is set
l453     Sprite palette latched from l440->l452, updated when w803 is set, goes to w812
l454     Same as l498 (from l499), on next DCLK posedge (i.e. 1 cycle later)
l455     (used to delay until l456)
l456     Set when l457 should be incremented (2 dots after l438 is set)
l457     Counter for sprite 8x1 silvers left to draw, NOT'd (note: 11 for the last one to draw)
l458     Set if w802 is within viewport range (from w810, 1 DCLK cycle later)
l459     Same as ~l498 (note the ~), 2 DCLK cycles later (goes to l460)
l460     Same as ~l498 (note the ~), 3 DCLK cycles later
l461     Selects whether we're drawing to the left or right of a 8px line buffer boundary (from w813, align to clk1)
l462     Signals when the linebuffer write enables happen (1 DCLK after w814, to w815)
l463     (used to stretch w814 for +1 DCLK)
l464     (used to stretch w951 for +1 DCLK)
l466     Latches the result of w820, delays by half a dot (aligns to hclk1)
l467     Latches bit 2 of w809, delays by 1 dot (so H counter[2:0] +6 in m4 or +7 in m5)
l468     Latches bit 1 of w809, delays by 1 dot (so H counter[2:0] +6 in m4 or +7 in m5)
l469     Latches bit 0 of w809, delays by 1 dot (so H counter[2:0] +6 in m4 or +7 in m5)
l470     Set while in viewport area and active scan (from w388->l471, 2 dots (4 DCLK) later)
l471     Set while in viewport area and active scan (from w388, 1 dot (2 DCLK) later, goes to l470)
l472     Bits 2:0 of the X coordinate when drawing sprites (from l473->w799, 1 more DCLK later)
l473     Bits 2:0 of the X coordinate when drawing sprites (from w799 to l472, loaded on w805)
l474     Linebuffer address when drawing into it
l475     Linebuffer address when showing it on screen (latched from w809, derived from H counter)
l478     4th byte (2nd word high byte) when reading sprite 8x1 pixels (from VRAM), latched on w834
l479     3rd byte (2nd word low byte) when reading sprite 8x1 pixels (from VRAM), latched on w833
l480     2nd byte (1st word high byte) when reading sprite 8x1 pixels (from VRAM), latched on w829
l481     1st byte (1st word low byte) when reading sprite 8x1 pixels (from VRAM), latched on w830
l482     Timing: set to latch 2nd byte (1st word high byte) of a sprite's 8x1 px (goes to w829 to limit it to a pulse)
l483     Timing: set to latch 1st byte (1st word low byte) of a sprite's 8x1 px (goes to w830 to limit it to a pulse)
l484     Timing: set to latch 3rd byte (2nd word low byte) of a sprite's 8x1 px (goes to w833 to limit it to a pulse)
l485     Timing: set to latch 4th byte (2nd word high byte) of a sprite's 8x1 px (goes to w834 to limit it to a pulse)
l486     3rd byte (2nd word low byte) when reading sprite 8x1 pixels (from l479), latched on w834
l487     2nd byte (1st word high byte) when reading sprite 8x1 pixels (from l480), latched on w834
l488     1st byte (1st word low byte) when reading sprite 8x1 pixels (from l481), latched on w834
l490     Timing: set to copy latched sprite 8x1 bytes into l491-l494 (the work copy) (goes to w835 to limit it to a pulse)
l491     4th byte (2nd word high byte) when reading sprite 8x1 pixels (from l478), latched on w835, used for processing
l492     3rd byte (2nd word low byte) when reading sprite 8x1 pixels (from l479->l486), latched on w835, used for processing
l493     2nd byte (1st word high byte) when reading sprite 8x1 pixels (from l480->l487), latched on w835, used for processing
l494     1st byte (1st word low byte) when reading sprite 8x1 pixels (from l481->l488), latched on w835, used for processing
l495     Set=0 to pick pixels #0 and #1 for w843_2 (for mode 4, without hflip support) (also used by w837)
l496     Set=0 to pick pixels #2 and #3 for w843_2 (for mode 4, without hflip support) (also used by w838)
l497     Set=0 to pick pixels #4 and #5 for w843_2 (for mode 4, without hflip support) (also used by w839)
l498     Set=0 to pick pixels #6 and #7 for w843_2 (for mode 4, without hflip support) (also used by w840)
l499     Same as l498, negated, on next DCLK negedge (0.5 cycles later)
l500     When 0, starts the chain to pick pixels for w843 (from l438, goes to w836, then to l495 and w846 on ~hclk2)
l501     (used for w843_1 and w847) m5 sprite hflip (from w795)
l502     Latches pair of sprite pixels (from w844) on DCLK negedge (goes to w845)
l503     X coordinate bits 2:1 from w799 (loaded on w846, incremented if not, +1 DCLK delay), used for l504
l504     Latches X coordinate from {l503,l506} on DCLK negedge (+1 DCLK delay from w799 and w846)
l505     X coordinate bit 0 from w799 (loaded on w846), used for l506->l504
l506     X coordinate bit 0 from l505 (+1 DCLK delay), used for l504 and w847
l507     Sprite render timing: w848, delayed by 1 dot
l508     Sprite render timing: w848, delayed by 2 dots
l509     Sprite render timing: w848, delayed by 3 dots
l510     Sprite render timing: w848, delayed by 4 dots
l511     Sprite render timing: w848, delayed by 4 dots if m5 or 5 dots if m4 (from w849)
l512     (latches w388) Set while in viewport area and active scan
l513     Used for edge detection of l512
l514     End of viewport area (from w850, negative edge detection for l512->l513, goes to w877)
l515     Line buffer write data color #0 (as pixels are being rotated, goes to l523)
l516     Line buffer write data color #1 (as pixels are being rotated, goes to l524)
l517     Line buffer write data color #2 (as pixels are being rotated, goes to l525)
l518     Line buffer write data color #3 (as pixels are being rotated, goes to l526)
l519     Line buffer write data color #4 (as pixels are being rotated, goes to l527)
l520     Line buffer write data color #5 (as pixels are being rotated, goes to l528)
l521     Line buffer write data color #6 (as pixels are being rotated, goes to l529)
l522     Line buffer write data color #7 (as pixels are being rotated, goes to l530)
l523     Line buffer write data color #0 (ready to use)
l524     Line buffer write data color #1 (ready to use)
l525     Line buffer write data color #2 (ready to use)
l526     Line buffer write data color #3 (ready to use)
l527     Line buffer write data color #4 (ready to use)
l528     Line buffer write data color #5 (ready to use)
l529     Line buffer write data color #6 (ready to use)
l530     Line buffer write data color #7 (ready to use)
l531     (from w851) Cleared during sprite drawing when X[2:0] is +1px (within an 8px boundary) (aligns to clk1)
l532     (from w867) Cleared during sprite drawing when X[2:0] is +2px (within an 8px boundary) (aligns to clk1)
l533     (from w868) Cleared during sprite drawing when X[2:0] is +3px (within an 8px boundary) (aligns to clk1)
l534     (from w869) Cleared during sprite drawing when X[2:0] is +4px (within an 8px boundary) (aligns to clk1)
l535     (from w827) Cleared during sprite drawing when X[2:0] is +5px (within an 8px boundary) (aligns to clk1)
l536     (from w870) Cleared during sprite drawing when X[2:0] is +6px (within an 8px boundary) (aligns to clk1)
l537     (from w871) Cleared during sprite drawing when X[2:0] is +7px (within an 8px boundary) (aligns to clk1)
l538     Line buffer write enable pixel #0 (from w902, before clock, to w910)
l539     Line buffer write enable pixel #1 (from w903, before clock, to w911)
l540     Line buffer write enable pixel #2 (from w904, before clock, to w912)
l541     Line buffer write enable pixel #3 (from w905, before clock, to w913)
l542     Line buffer write enable pixel #4 (from w906, before clock, to w914)
l543     Line buffer write enable pixel #5 (from w907, before clock, to w915)
l544     Line buffer write enable pixel #6 (from w908, before clock, to w916)
l545     Line buffer write enable pixel #7 (from w909, before clock, to w917)
l553     Used to delay sprite layer palette from line buffer? (delayed by 1 dot in mode 5, see w970)
l554     Used to delay sprite layer priority from line buffer? (delayed by 1 dot in mode 5, see w971)
l555     Used to delay sprite layer color from line buffer? (delayed by 1 dot in mode 5, see w972)
l556     (latches w970's value and delays it by 1 more dot)
l557     (latches w971's value and delays it by 1 more dot)
l558     (latches w972's value and delays it by 1 more dot)
l559     Sprite color palette to show (from w974, to color bus mux)
l560     Sprite priority to show (from w973, to color bus mux)
l561     Sprite color index to show (from l558, to color bus mux)
l562     Stores w877 and delays it by 1 dot (to next DCLK negedge)
l568     VRAM write to lower byte (from w991, delayed by one dot)
l571     VRAM write to upper byte (latched from w286, goes to w991)
l574     (use unknown?) Free VRAM slot (CPU access allowed) (latched from l109)
l583     Set to output the latched RD_i/AD_i on the VRAM data bus
l584     VRAM write to upper byte (from w999, delayed by one dot)
l585     VRAM write to lower byte (latched from w288, goes to w999)
l586     0: enable 1st VRAM serial bus (/SE0), 1: enable 2nd VRAM serial bus (/SE1)
l587     H Timing signal: refresh slot (from w1008, introduces 3 dots of latency, pulse is 2 dots long)
l588     H Timing signal: refresh slot (from w476->l108, introduces 2 dots of latency)
l589     H Timing signal: refresh slot (from w476->l108->l588, introduces 3 dots of latency)
l592     Physical VRAM address (upper half, latched from w1012)
l593     Physical VRAM address (lower half, latched from w1014)
l600     Set sprite collision flag
l601     CRAM write, upper byte (latched from w302)
l602     CRAM write, lower byte (latched from w303)
l603     Show sprite plane (from w1044, goes to color bus)
l604     Show plane A (from w1051, goes to color bus)
l605     Show plane B (from w1058, goes to color bus)
l606     Show background plane (from w1061, goes to color bus)
l607     Highlight flag (from w1066, used 3 dots later in l630)
l608     Shadow flag (from w1068, used 3 dots later in l629)
l609     (delays w1069, goes to l610->l629->DAC)
l610     (from l610, goes to l629->DAC) Shadow flag reported from reading test reg 4
l611     (delays w1070, goes to l612->l630->DAC)
l612     (from l612, goes to l630->DAC) Highlight flag reported from reading test reg 4
l615     SPA/B pin's input (logic reversed from pin!)
l617     CRAM address to access (from w1076)
l618     (from w1075, delayed by 3 dots) Set when going to output viewport pixels?
l619     Set if output color is transparent (latched from w1077, goes to l625)
l620     CRAM write: data for "blue" bits (internal bits 8:6)
l622     Latched RGB color to output (BBBGGGRRR or xxxBBGGRR)
l623_1   Used to time CRAM read output (1 dot later than w178, value is latched here)
l623_2   Used to time CRAM read output (2 dots later than w178)
l623_3   Used to time CRAM read output (3 dots later than w178, value is output here)
l624     Enable color output on RGB pins (from w1081)
l625     Set if output color is transparent (latched from l619)
l626     Red color output (0..7, before S/H takes effect)
l627     Green color output (0..7, before S/H takes effect)
l628     Blue color output (0..7, before S/H takes effect)
l629     Shadow color flag? (also see w1102)
l630     Highlight color flag (see w1101/w1102 for normal/shadow) (for RGB DAC use only)
l635     Acknowledges the PSG write strobe internally, goes to l636 and sets t43
l636     Set to execute a PSG command (delayed from l635 by a PSG cycle)
l637     Used to reset PSG registers
l640     Shift register for PSG noise
l641     PSG frequency counter (rotating, goes to l642)
l642     PSG frequency counter (rotating, goes to l643)
l643     PSG frequency counter (rotating, goes to l644)
l644     PSG frequency counter (rotating, goes to l641, used for current channel)
l653     Latch to hold byte written to PSG port
l654     Selected PSG register, I think? (bits 6:4 of a command with bit 7 set)
l655     PSG square channel #1 volume
l656     PSG square channel #2 volume
l657     PSG square channel #3 volume
l658     PSG noise channel volume
l659     PSG square channel #1 frequency
l660     PSG square channel #2 frequency
l661     PSG square channel #3 frequency
l662     PSG noise channel type/frequency
l663     Vsync (for mode 4)

t1       Set when writing reg $17 with DMD1=0, clear when CPU bus grant (or reset)
t2       "In DMA copy/fill" flag
t3       BGACK (low logic)
t4       "In DMA transfer" flag
t5       Set when interrupt acknowledge arrives
t7       Hblank interrupt pending
t8       External interrupt pending
t9       Vblank interrupt pending (status port F bit)
t10      Status port SOVR bit
t11      Status port C bit
t12      Set to fire the interrupt in MD mode (be more specific?)
t13      CPU access to DATA/CTRL detected
t14      Seems to be set while VDP is waiting for data from VRAM/CRAM/VSRAM to be latched on a read
t15      Which command byte to write next in SMS mode? (t16 gated by w154?)
t16      Which command byte to write next in SMS mode?
t18      Which command word to write next? (0: low, 1: high)
t19      CPU upper byte strobe (set by UDS, clear by w183)
t20      CPU lower byte strobe (set by LDS, clear by w183)
t21      In the middle of a DATA port write (set by w169, clear by w183)
t25      Writing command bits 15:8 (set by w164, clear by w176)
t28      Set when a FIFO entry is flushed during DMA, reset when DMA finishes
t29      Set when in viewport area (horizontally)
t30      Internal hblank flag (delayed further down the line)
t31      ??? (seems to be used as part of the hsync portion of csync)
t32      hsync (short pulses, delayed further down the line)
t33      hsync (normal pulses, delayed further down the line)
t34      2nd equalization pulse range? (set for 3 lines after vsync)
t35      vsync (w/o including the delay for mode 5)
t36      1st equalization pulse range? (set 3 for lines before vsync)
t37      disable color output (vertical)
t38      in viewport area? (vertical)
t43      Write enable for PSG (low logic, reset by PSG write, set by l635 when done)

cpu_sel        1 = 68000, 0 = Z80

reg_80_b0      Reg 00:0 = external sync
reg_m3         Reg 00:1 = mode 5 HV counter latch
reg_80_b2      Reg 00:2 = mode 4 enable (that bit that messes with color depth)
reg_80_b3      Reg 00:3 = mode 4 sprite shift
reg_ie1        Reg 00:4 = hblank interrupt enable
reg_lcb        Reg 00:5 = left column blank
reg_80_b6      Reg 00:6 = mode 4 hscroll inhibit
reg_80_b7      Reg 00:7 = mode 4 vscroll inhibit

reg_81_b0      Reg 01:0 = mode 4 MAG bit
reg_81_b1      Reg 01:1 = mode 4 sprite size
reg_m5         Reg 01:2 = mode 5 enable
reg_m2         Reg 01:3 = V28/V30 select
reg_m1         Reg 01:4 = DMA enable
reg_ie0        Reg 01:5 = vblank interrupt enable
reg_disp       Reg 01:6 = display enable
reg_81_b7      Reg 01:7 = VRAM bus mode

reg_lscr       Reg 0B:0 = hscroll mode
reg_hscr       Reg 0B:1 = hscroll mode
reg_vscr       Reg 0B:2 = vscroll mode
reg_ie2        Reg 0B:3 = external interrupt enable
reg_8b_b4      Reg 0B:4 = VRAM address MSB override
reg_8b_b5      Reg 0B:5 = VRAM address MSB select
reg_8b_b6      Reg 0B:6 = DRAM operation
reg_8b_b7      Reg 0B:7 = DRAM address vs. color bus output

reg_rs1        Reg 0C:0 = H32/H40 select
reg_lsm0       Reg 0C:1 = interlaced mode select
reg_lsm1       Reg 0C:2 = interlaced mode select
reg_ste        Reg 0C:3 = shadow/highlight enable
reg_8c_b4      Reg 0C:4 = SPA/B pin direction (input=0, output=1)
reg_8c_b5      Reg 0C:5 = /HSYNC pin direction (output=0, input=1)
reg_8c_b6      Reg 0C:6 = select between vsync(0) or hclk2(1) for /VSYNC
reg_rs0        Reg 0C:7 = DCLK/EDCLK select

reg_86_b2      Reg 06:2 = sprite bank in mode 4
reg_86_b5      Reg 06:5 = sprite bank in mode 5
reg_8e_b0      Reg 0E:0 = plane A bank in mode 5
reg_8e_b4      Reg 0E:4 = plane B bank in mode 5

reg_sa         Reg 02:6/3 = plane A table address (mode 5)
reg_nt         Reg 02:2/1 = plane A table address (mode 4)
reg_sb         Reg 04:3/0 = plane B table address
reg_wd         Reg 03:6/1 = window table address
reg_at         Reg 05:7/0 = sprite table address
reg_hs         Reg 0D:6/0 = hscroll table address

reg_hsz        Reg 10:1/0 = plane A/B width
reg_vsz        Reg 10:5/4 = plane A/B height
reg_rigt       Reg 11:7   = window X split direction
reg_whp        Reg 11:4/0 = window X split point
reg_down       Reg 12:7   = window Y split direction
reg_wvp        Reg 12:4/0 = window Y split point
reg_88         Reg 08 = mode 4 hscroll
l179           Reg 09 = mode 4 vscroll

reg_col_index  Reg 07:3/0 = background color
reg_col_pal    Reg 07:5/4 = background palette
reg_col_b6     Reg 07:6
reg_col_b7     Reg 07:7

reg_inc        Reg 0F = autoincrement
reg_lg         Reg 13/14 = DMA length
reg_sa_low     Reg 16/15 = DMA source address low
reg_sa_high    Reg 17:5/0 = DMA source address high
reg_dmd        Reg 17:7/6 = DMA type

reg_code       Command CD5:0 input
reg_addr       Command address input
reg_data_l2    Current command address
reg_data_sum   Autoincremented address
reg_data_mux   Current or incremented address (see w185)

reg_test_18    Selected test port
reg_test0      Test port #0
reg_test1      Test port #1

unk_data       Data to write to VRAM/CRAM/VSRAM (from the FIFO, goes to l104)

r_col          Checks for each possible red level, before S/H
g_col          Checks for each possible green level, before S/H
b_col          Checks for each possible blue level, before S/H


* Register write enables at w210..w233 (not in order, see below)

      $00 w216    $08 w231    $10 w224
      $01 w217    $09 w230    $11 w223
      $02 w218    $0A w229    $12 w222
      $03 w219    $0B w213    $13 w211
      $04 w220    $0C w215    $14 w212
      $05 w226    $0D w233    $15 w228
      $06 w225    $0E w232    $16 w214
      $07 w221    $0F w210    $17 w227

* w942..w949 determine whether a sprite pixel can be rewritten or not. They're
  muxes: looks like w950 would have picked between underdraw or overdraw (i.e.
  front to back or back to front), but in practice it's hardwired to always do
  underdraw.

* YS is overriden by test reg $0 bit 5: when set, it outputs VRAM address MSB.

* CRAM in mode 4 stores the colors as xxxbbggrr internally (removing the gaps).
  The "xxx" is stored from data bus bits 11:9 as usual (what would be "bbb" in
  mode 5), but this would be out of reach from the Z80 (would it be open bus or
  what else?). 68000 should be able to write to those, however.


Line 2762      CPU address decoding
Line 2979      Register write enables
Line 3287      HV counter latch?
Line 3013      FIFO storage? (address)
Line 3306      FIFO storage? (data)
Line 3345      Command CD4:0 input latch (reg_code[4:0], where's CD5?)
Line 3348      Command address input latch (reg_addr)
Line 3355      Command address latch (reg_data_l2)
Line 3361      Register $00 latch
Line 3371      Register $0C latch
Line 3380      Register $01 latch
Line 3390      Register $0B latch
Line 3399      Register $0F latch
Line 3401      Register $17 latch
Line 3405      Register $13 latch
Line 3408      Register $14 latch
Line 3411      Register $15 latch
Line 3414      Register $16 latch
Line 3831      PLA V
Line 3880      PLA H #1
Line 3944      PLA H #2
Line 4598      CRAM address set
Line 5972      Sprite table cache
Line 6020      Sprite drawing?
Line 6067      Line buffer
Line 6073      Line buffer data input
Line 6120      Line buffer write
Line 6139      Line buffer read
Line 6268      VRAM physical address
Line 6322      Layer muxer
Line 6453      Register $07 latch
Line 7106      Data bus pin output
Line 7122      Data bus pin direction
